diff --git a/arch/arm64/configs/imx8mm_diasom_evb_defconfig b/arch/arm64/configs/imx8mm_diasom_evb_defconfig
new file mode 100644
index 000000000000..2dd910de7676
--- /dev/null
+++ b/arch/arm64/configs/imx8mm_diasom_evb_defconfig
@@ -0,0 +1,549 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+# CONFIG_INITRAMFS_PRESERVE_MTIME is not set
+# CONFIG_SYSFS_SYSCALL is not set
+# CONFIG_FHANDLE is not set
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_ARCH_NXP=y
+CONFIG_ARCH_MXC=y
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_ARM64_ERRATUM_1742098 is not set
+# CONFIG_ARM64_ERRATUM_1024718 is not set
+# CONFIG_ARM64_ERRATUM_1418040 is not set
+# CONFIG_ARM64_ERRATUM_1165522 is not set
+# CONFIG_ARM64_ERRATUM_1319367 is not set
+# CONFIG_ARM64_ERRATUM_1530923 is not set
+# CONFIG_ARM64_ERRATUM_2441007 is not set
+# CONFIG_ARM64_ERRATUM_1286807 is not set
+# CONFIG_ARM64_ERRATUM_1463225 is not set
+# CONFIG_ARM64_ERRATUM_1542419 is not set
+# CONFIG_ARM64_ERRATUM_1508412 is not set
+# CONFIG_ARM64_ERRATUM_2051678 is not set
+# CONFIG_ARM64_ERRATUM_2077057 is not set
+# CONFIG_ARM64_ERRATUM_2658417 is not set
+# CONFIG_ARM64_ERRATUM_2054223 is not set
+# CONFIG_ARM64_ERRATUM_2067961 is not set
+# CONFIG_ARM64_ERRATUM_2441009 is not set
+# CONFIG_ARM64_ERRATUM_2457168 is not set
+# CONFIG_ARM64_ERRATUM_2645198 is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_CAVIUM_ERRATUM_30115 is not set
+# CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
+# CONFIG_FUJITSU_ERRATUM_010001 is not set
+# CONFIG_HISILICON_ERRATUM_161600802 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1003 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1009 is not set
+# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_E1041 is not set
+# CONFIG_NVIDIA_CARMEL_CNP_ERRATUM is not set
+# CONFIG_ROCKCHIP_ERRATUM_3588001 is not set
+# CONFIG_SOCIONEXT_SYNQUACER_PREITS is not set
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_HZ_1000=y
+# CONFIG_UNMAP_KERNEL_AT_EL0 is not set
+# CONFIG_MITIGATE_SPECTRE_BRANCH_HISTORY is not set
+# CONFIG_RODATA_FULL_DEFAULT_ENABLED is not set
+CONFIG_ARM64_SW_TTBR0_PAN=y
+CONFIG_COMPAT=y
+CONFIG_COMPAT_ALIGNMENT_FIXUPS=y
+CONFIG_ARM64_PMEM=y
+CONFIG_ARM64_PSEUDO_NMI=y
+# CONFIG_EFI is not set
+CONFIG_ENERGY_MODEL=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_CPU_IDLE_GOV_TEO=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_IMX_CPUFREQ_DT=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_VMAP_STACK is not set
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEBUG_FS is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_CMDLINE_PARTITION=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_COREDUMP is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+# CONFIG_ZONE_DMA is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_SECRETMEM is not set
+CONFIG_USERFAULTFD=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_INET_RAW_DIAG=y
+CONFIG_INET_DIAG_DESTROY=y
+# CONFIG_IPV6 is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEASPM_POWERSAVE=y
+# CONFIG_VGA_ARB is not set
+CONFIG_PCI_IMX6_HOST=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_ARM_SMCCC_SOC_ID is not set
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTD_NAND_GPMI_NAND=y
+# CONFIG_MTD_NAND_ECC_SW_HAMMING is not set
+CONFIG_BLK_DEV_NVME=y
+CONFIG_SRAM=y
+CONFIG_EEPROM_AT24=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+# CONFIG_ATA_FORCE is not set
+# CONFIG_SATA_PMP is not set
+CONFIG_AHCI_IMX=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ASIX is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CADENCE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_NET_VENDOR_DAVICOM is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_ENGLEDER is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+CONFIG_FEC=y
+# CONFIG_NET_VENDOR_FUNGIBLE is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_ADI is not set
+# CONFIG_NET_VENDOR_LITEX is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+# CONFIG_NET_VENDOR_MICROSOFT is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETERION is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_NET_VENDOR_PACKET_ENGINES is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VERTEXCOM is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WANGXUN is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_NET_VENDOR_XILINX is not set
+CONFIG_DP83867_PHY=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_SNVS_PWRKEY=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_SERIO is not set
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_TIMERIOMEM=y
+# CONFIG_HW_RANDOM_CN10K is not set
+# CONFIG_DEVPORT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_GPIO=y
+CONFIG_I2C_GPIO_FAULT_INJECTOR=y
+CONFIG_I2C_IMX=y
+CONFIG_SPI=y
+CONFIG_SPI_NXP_FLEXSPI=y
+CONFIG_SPI_IMX=y
+CONFIG_SPI_SPIDEV=y
+# CONFIG_PTP_1588_CLOCK_KVM is not set
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_IMX8MM=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_MXC=y
+CONFIG_SYSCON_REBOOT_MODE=y
+# CONFIG_HWMON is not set
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR=y
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_IMX8MM_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_IMX2_WDT=y
+CONFIG_MFD_ROHM_BD718XX=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_BD718XX=y
+CONFIG_MEDIA_SUPPORT=y
+# CONFIG_DVB_NET is not set
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+# CONFIG_RADIO_ADAPTERS is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_IMX7_CSI=y
+CONFIG_VIDEO_IMX_MIPI_CSIS=y
+CONFIG_VIDEO_HANTRO=y
+CONFIG_VIDEO_OV5640=y
+# CONFIG_CXD2880_SPI_DRV is not set
+# CONFIG_MEDIA_TUNER_E4000 is not set
+# CONFIG_MEDIA_TUNER_FC0011 is not set
+# CONFIG_MEDIA_TUNER_FC0012 is not set
+# CONFIG_MEDIA_TUNER_FC0013 is not set
+# CONFIG_MEDIA_TUNER_FC2580 is not set
+# CONFIG_MEDIA_TUNER_IT913X is not set
+# CONFIG_MEDIA_TUNER_M88RS6000T is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MSI001 is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MXL301RF is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_QM1D1B0004 is not set
+# CONFIG_MEDIA_TUNER_QM1D1C0042 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_R820T is not set
+# CONFIG_MEDIA_TUNER_SI2157 is not set
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18250 is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_TUA9001 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_DVB_MXL5XX is not set
+# CONFIG_DVB_STB0899 is not set
+# CONFIG_DVB_STB6100 is not set
+# CONFIG_DVB_STV090x is not set
+# CONFIG_DVB_STV0910 is not set
+# CONFIG_DVB_STV6110x is not set
+# CONFIG_DVB_STV6111 is not set
+# CONFIG_DVB_DRXK is not set
+# CONFIG_DVB_MN88472 is not set
+# CONFIG_DVB_MN88473 is not set
+# CONFIG_DVB_SI2165 is not set
+# CONFIG_DVB_TDA18271C2DD is not set
+# CONFIG_DVB_CX24110 is not set
+# CONFIG_DVB_CX24116 is not set
+# CONFIG_DVB_CX24117 is not set
+# CONFIG_DVB_CX24120 is not set
+# CONFIG_DVB_CX24123 is not set
+# CONFIG_DVB_DS3000 is not set
+# CONFIG_DVB_MB86A16 is not set
+# CONFIG_DVB_MT312 is not set
+# CONFIG_DVB_S5H1420 is not set
+# CONFIG_DVB_SI21XX is not set
+# CONFIG_DVB_STB6000 is not set
+# CONFIG_DVB_STV0288 is not set
+# CONFIG_DVB_STV0299 is not set
+# CONFIG_DVB_STV0900 is not set
+# CONFIG_DVB_STV6110 is not set
+# CONFIG_DVB_TDA10071 is not set
+# CONFIG_DVB_TDA10086 is not set
+# CONFIG_DVB_TDA8083 is not set
+# CONFIG_DVB_TDA8261 is not set
+# CONFIG_DVB_TDA826X is not set
+# CONFIG_DVB_TS2020 is not set
+# CONFIG_DVB_TUA6100 is not set
+# CONFIG_DVB_TUNER_CX24113 is not set
+# CONFIG_DVB_TUNER_ITD1000 is not set
+# CONFIG_DVB_VES1X93 is not set
+# CONFIG_DVB_ZL10036 is not set
+# CONFIG_DVB_ZL10039 is not set
+# CONFIG_DVB_CX22700 is not set
+# CONFIG_DVB_CX22702 is not set
+# CONFIG_DVB_CXD2820R is not set
+# CONFIG_DVB_CXD2841ER is not set
+# CONFIG_DVB_DIB3000MB is not set
+# CONFIG_DVB_DIB3000MC is not set
+# CONFIG_DVB_DIB7000M is not set
+# CONFIG_DVB_DIB7000P is not set
+# CONFIG_DVB_DIB9000 is not set
+# CONFIG_DVB_DRXD is not set
+# CONFIG_DVB_EC100 is not set
+# CONFIG_DVB_L64781 is not set
+# CONFIG_DVB_MT352 is not set
+# CONFIG_DVB_NXT6000 is not set
+# CONFIG_DVB_S5H1432 is not set
+# CONFIG_DVB_SP887X is not set
+# CONFIG_DVB_STV0367 is not set
+# CONFIG_DVB_TDA10048 is not set
+# CONFIG_DVB_TDA1004X is not set
+# CONFIG_DVB_ZD1301_DEMOD is not set
+# CONFIG_DVB_ZL10353 is not set
+# CONFIG_DVB_CXD2880 is not set
+# CONFIG_DVB_STV0297 is not set
+# CONFIG_DVB_TDA10021 is not set
+# CONFIG_DVB_TDA10023 is not set
+# CONFIG_DVB_VES1820 is not set
+# CONFIG_DVB_AU8522_DTV is not set
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_BCM3510 is not set
+# CONFIG_DVB_LG2160 is not set
+# CONFIG_DVB_LGDT3305 is not set
+# CONFIG_DVB_LGDT330X is not set
+# CONFIG_DVB_MXL692 is not set
+# CONFIG_DVB_NXT200X is not set
+# CONFIG_DVB_OR51132 is not set
+# CONFIG_DVB_OR51211 is not set
+# CONFIG_DVB_S5H1409 is not set
+# CONFIG_DVB_S5H1411 is not set
+# CONFIG_DVB_DIB8000 is not set
+# CONFIG_DVB_MB86A20S is not set
+# CONFIG_DVB_S921 is not set
+# CONFIG_DVB_MN88443X is not set
+# CONFIG_DVB_TC90522 is not set
+# CONFIG_DVB_PLL is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+# CONFIG_DVB_A8293 is not set
+# CONFIG_DVB_AF9033 is not set
+# CONFIG_DVB_ASCOT2E is not set
+# CONFIG_DVB_ATBM8830 is not set
+# CONFIG_DVB_HELENE is not set
+# CONFIG_DVB_HORUS3A is not set
+# CONFIG_DVB_ISL6405 is not set
+# CONFIG_DVB_ISL6421 is not set
+# CONFIG_DVB_ISL6423 is not set
+# CONFIG_DVB_IX2505V is not set
+# CONFIG_DVB_LGS8GL5 is not set
+# CONFIG_DVB_LGS8GXX is not set
+# CONFIG_DVB_LNBH25 is not set
+# CONFIG_DVB_LNBH29 is not set
+# CONFIG_DVB_LNBP21 is not set
+# CONFIG_DVB_LNBP22 is not set
+# CONFIG_DVB_M88RS2000 is not set
+# CONFIG_DVB_TDA665x is not set
+# CONFIG_DVB_DRX39XYJ is not set
+# CONFIG_DVB_CXD2099 is not set
+# CONFIG_DVB_SP2 is not set
+CONFIG_DRM=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+CONFIG_DRM_DISPLAY_CONNECTOR=y
+CONFIG_DRM_SAMSUNG_DSIM=y
+CONFIG_DRM_I2C_ADV7511=y
+CONFIG_DRM_ETNAVIV=y
+CONFIG_DRM_MXSFB=y
+CONFIG_FB=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_DYNAMIC_MINORS=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_PCI is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_AUDIO_MIDI_V2=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_FSL_SAI=y
+CONFIG_SND_SOC_FSL_MICFIL=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+CONFIG_SND_SOC_BT_SCO=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_USB_HIDDEV=y
+# CONFIG_I2C_HID is not set
+CONFIG_USB_CONN_GPIO=y
+CONFIG_USB=y
+# CONFIG_USB_PCI is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_FEW_INIT_RETRIES=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_FSL=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_HOST=y
+# CONFIG_USB_CHIPIDEA_MSM is not set
+# CONFIG_USB_CHIPIDEA_GENERIC is not set
+# CONFIG_USB_CHIPIDEA_TEGRA is not set
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_ACTIVITY=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SNVS=y
+CONFIG_DMADEVICES=y
+CONFIG_IMX_SDMA=y
+CONFIG_MXS_DMA=y
+# CONFIG_MX3_IPU is not set
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+CONFIG_DMABUF_HEAPS_CMA=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+CONFIG_CLK_IMX8MM=y
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_ARM64_ERRATUM_858921 is not set
+CONFIG_IMX_MBOX=y
+CONFIG_IOMMU_IO_PGTABLE_LPAE=y
+CONFIG_REMOTEPROC=y
+CONFIG_IMX_REMOTEPROC=y
+# CONFIG_SOC_IMX9 is not set
+CONFIG_PWM=y
+CONFIG_PWM_IMX27=y
+# CONFIG_IMX_IRQSTEER is not set
+# CONFIG_IMX_MU_MSI is not set
+CONFIG_RESET_IMX7=y
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+CONFIG_PHY_FSL_IMX8M_PCIE=y
+CONFIG_FSL_IMX8_DDR_PMU=y
+CONFIG_NVMEM_IMX_OCOTP=y
+CONFIG_NVMEM_SNVS_LPGPR=y
+CONFIG_INTERCONNECT=y
+CONFIG_INTERCONNECT_IMX=y
+CONFIG_INTERCONNECT_IMX8MM=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_F2FS_FS=y
+# CONFIG_F2FS_STAT_FS is not set
+# CONFIG_F2FS_FS_XATTR is not set
+# CONFIG_F2FS_IOSTAT is not set
+CONFIG_FSCACHE=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=866
+CONFIG_FAT_DEFAULT_IOCHARSET="cp1251"
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_EXFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+# CONFIG_PROC_PAGE_MONITOR is not set
+CONFIG_CONFIGFS_FS=y
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_UTF8=y
+CONFIG_LSM="landlock,lockdown,yama,loadpin,safesetid,selinux,smack,tomoyo,apparmor,bpf"
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_HW is not set
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_PANIC_TIMEOUT=5
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_FTRACE is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff --git a/arch/arm64/configs/rk3568_mg_evb_defconfig b/arch/arm64/configs/rk3568_mg_evb_defconfig
new file mode 100644
index 000000000000..fd2c54ffa64c
--- /dev/null
+++ b/arch/arm64/configs/rk3568_mg_evb_defconfig
@@ -0,0 +1,568 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+# CONFIG_INITRAMFS_PRESERVE_MTIME is not set
+# CONFIG_SYSFS_SYSCALL is not set
+# CONFIG_FHANDLE is not set
+CONFIG_EMBEDDED=y
+CONFIG_ARCH_ROCKCHIP=y
+# CONFIG_AMPERE_ERRATUM_AC03_CPU_38 is not set
+# CONFIG_ARM64_ERRATUM_826319 is not set
+# CONFIG_ARM64_ERRATUM_827319 is not set
+# CONFIG_ARM64_ERRATUM_824069 is not set
+# CONFIG_ARM64_ERRATUM_819472 is not set
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_ARM64_ERRATUM_1742098 is not set
+# CONFIG_ARM64_ERRATUM_845719 is not set
+# CONFIG_ARM64_ERRATUM_843419 is not set
+# CONFIG_ARM64_ERRATUM_1418040 is not set
+# CONFIG_ARM64_ERRATUM_1165522 is not set
+# CONFIG_ARM64_ERRATUM_1319367 is not set
+# CONFIG_ARM64_ERRATUM_1286807 is not set
+# CONFIG_ARM64_ERRATUM_1463225 is not set
+# CONFIG_ARM64_ERRATUM_1542419 is not set
+# CONFIG_ARM64_ERRATUM_1508412 is not set
+# CONFIG_ARM64_ERRATUM_2051678 is not set
+# CONFIG_ARM64_ERRATUM_2077057 is not set
+# CONFIG_ARM64_ERRATUM_2658417 is not set
+# CONFIG_ARM64_ERRATUM_2054223 is not set
+# CONFIG_ARM64_ERRATUM_2067961 is not set
+# CONFIG_ARM64_ERRATUM_2441009 is not set
+# CONFIG_ARM64_ERRATUM_2457168 is not set
+# CONFIG_ARM64_ERRATUM_2645198 is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_CAVIUM_ERRATUM_30115 is not set
+# CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
+# CONFIG_FUJITSU_ERRATUM_010001 is not set
+# CONFIG_HISILICON_ERRATUM_161600802 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1003 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1009 is not set
+# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_E1041 is not set
+# CONFIG_NVIDIA_CARMEL_CNP_ERRATUM is not set
+# CONFIG_SOCIONEXT_SYNQUACER_PREITS is not set
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_HZ_1000=y
+# CONFIG_UNMAP_KERNEL_AT_EL0 is not set
+# CONFIG_MITIGATE_SPECTRE_BRANCH_HISTORY is not set
+# CONFIG_RODATA_FULL_DEFAULT_ENABLED is not set
+CONFIG_ARM64_SW_TTBR0_PAN=y
+CONFIG_COMPAT=y
+CONFIG_COMPAT_ALIGNMENT_FIXUPS=y
+CONFIG_ARM64_PSEUDO_NMI=y
+# CONFIG_EFI is not set
+CONFIG_ENERGY_MODEL=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_CPU_IDLE_GOV_TEO=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_SCMI_CPUFREQ=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_VMAP_STACK is not set
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEBUG_FS is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_CMDLINE_PARTITION=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_COREDUMP is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_CMA=y
+# CONFIG_ZONE_DMA is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_SECRETMEM is not set
+CONFIG_USERFAULTFD=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_INET_RAW_DIAG=y
+CONFIG_INET_DIAG_DESTROY=y
+# CONFIG_IPV6 is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_CAN=y
+# CONFIG_CAN_BCM is not set
+# CONFIG_CAN_GW is not set
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEASPM_POWERSAVE=y
+# CONFIG_VGA_ARB is not set
+CONFIG_PCIE_ROCKCHIP_DW_HOST=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_ARM_SCMI_PROTOCOL=y
+# CONFIG_ARM_SCMI_POWER_DOMAIN is not set
+# CONFIG_ARM_SMCCC_SOC_ID is not set
+CONFIG_BLK_DEV_NVME=y
+CONFIG_SRAM=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+# CONFIG_ATA_FORCE is not set
+# CONFIG_SATA_PMP is not set
+CONFIG_AHCI_DWC=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ASIX is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CADENCE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_NET_VENDOR_DAVICOM is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_ENGLEDER is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_FUNGIBLE is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_ADI is not set
+# CONFIG_NET_VENDOR_LITEX is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+# CONFIG_NET_VENDOR_MICROSOFT is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETERION is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_NET_VENDOR_PACKET_ENGINES is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+CONFIG_STMMAC_ETH=y
+# CONFIG_DWMAC_GENERIC is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VERTEXCOM is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WANGXUN is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_NET_VENDOR_XILINX is not set
+CONFIG_REALTEK_PHY=y
+CONFIG_ROCKCHIP_PHY=y
+CONFIG_CANFD_ROCKCHIP=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_RK805_PWRKEY=y
+# CONFIG_SERIO is not set
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_NR_UARTS=10
+CONFIG_SERIAL_8250_RUNTIME_UARTS=10
+CONFIG_SERIAL_8250_DW=y
+# CONFIG_SERIAL_8250_PERICOM is not set
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_TIMERIOMEM=y
+# CONFIG_HW_RANDOM_CN10K is not set
+# CONFIG_DEVPORT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_RK3X=y
+CONFIG_SPI=y
+CONFIG_SPI_ROCKCHIP=y
+CONFIG_SPI_SPIDEV=y
+# CONFIG_PTP_1588_CLOCK_KVM is not set
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_SYSCON_REBOOT_MODE=y
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR=y
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_ROCKCHIP_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_MFD_RK8XX_I2C=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_RK808=y
+CONFIG_MEDIA_SUPPORT=y
+# CONFIG_DVB_NET is not set
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+# CONFIG_RADIO_ADAPTERS is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_ROCKCHIP_RGA=y
+CONFIG_VIDEO_HANTRO=y
+# CONFIG_CXD2880_SPI_DRV is not set
+# CONFIG_MEDIA_TUNER_E4000 is not set
+# CONFIG_MEDIA_TUNER_FC0011 is not set
+# CONFIG_MEDIA_TUNER_FC0012 is not set
+# CONFIG_MEDIA_TUNER_FC0013 is not set
+# CONFIG_MEDIA_TUNER_FC2580 is not set
+# CONFIG_MEDIA_TUNER_IT913X is not set
+# CONFIG_MEDIA_TUNER_M88RS6000T is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MSI001 is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MXL301RF is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_QM1D1B0004 is not set
+# CONFIG_MEDIA_TUNER_QM1D1C0042 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_R820T is not set
+# CONFIG_MEDIA_TUNER_SI2157 is not set
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18250 is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_TUA9001 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_DVB_MXL5XX is not set
+# CONFIG_DVB_STB0899 is not set
+# CONFIG_DVB_STB6100 is not set
+# CONFIG_DVB_STV090x is not set
+# CONFIG_DVB_STV0910 is not set
+# CONFIG_DVB_STV6110x is not set
+# CONFIG_DVB_STV6111 is not set
+# CONFIG_DVB_DRXK is not set
+# CONFIG_DVB_MN88472 is not set
+# CONFIG_DVB_MN88473 is not set
+# CONFIG_DVB_SI2165 is not set
+# CONFIG_DVB_TDA18271C2DD is not set
+# CONFIG_DVB_CX24110 is not set
+# CONFIG_DVB_CX24116 is not set
+# CONFIG_DVB_CX24117 is not set
+# CONFIG_DVB_CX24120 is not set
+# CONFIG_DVB_CX24123 is not set
+# CONFIG_DVB_DS3000 is not set
+# CONFIG_DVB_MB86A16 is not set
+# CONFIG_DVB_MT312 is not set
+# CONFIG_DVB_S5H1420 is not set
+# CONFIG_DVB_SI21XX is not set
+# CONFIG_DVB_STB6000 is not set
+# CONFIG_DVB_STV0288 is not set
+# CONFIG_DVB_STV0299 is not set
+# CONFIG_DVB_STV0900 is not set
+# CONFIG_DVB_STV6110 is not set
+# CONFIG_DVB_TDA10071 is not set
+# CONFIG_DVB_TDA10086 is not set
+# CONFIG_DVB_TDA8083 is not set
+# CONFIG_DVB_TDA8261 is not set
+# CONFIG_DVB_TDA826X is not set
+# CONFIG_DVB_TS2020 is not set
+# CONFIG_DVB_TUA6100 is not set
+# CONFIG_DVB_TUNER_CX24113 is not set
+# CONFIG_DVB_TUNER_ITD1000 is not set
+# CONFIG_DVB_VES1X93 is not set
+# CONFIG_DVB_ZL10036 is not set
+# CONFIG_DVB_ZL10039 is not set
+# CONFIG_DVB_CX22700 is not set
+# CONFIG_DVB_CX22702 is not set
+# CONFIG_DVB_CXD2820R is not set
+# CONFIG_DVB_CXD2841ER is not set
+# CONFIG_DVB_DIB3000MB is not set
+# CONFIG_DVB_DIB3000MC is not set
+# CONFIG_DVB_DIB7000M is not set
+# CONFIG_DVB_DIB7000P is not set
+# CONFIG_DVB_DIB9000 is not set
+# CONFIG_DVB_DRXD is not set
+# CONFIG_DVB_EC100 is not set
+# CONFIG_DVB_L64781 is not set
+# CONFIG_DVB_MT352 is not set
+# CONFIG_DVB_NXT6000 is not set
+# CONFIG_DVB_S5H1432 is not set
+# CONFIG_DVB_SP887X is not set
+# CONFIG_DVB_STV0367 is not set
+# CONFIG_DVB_TDA10048 is not set
+# CONFIG_DVB_TDA1004X is not set
+# CONFIG_DVB_ZD1301_DEMOD is not set
+# CONFIG_DVB_ZL10353 is not set
+# CONFIG_DVB_CXD2880 is not set
+# CONFIG_DVB_STV0297 is not set
+# CONFIG_DVB_TDA10021 is not set
+# CONFIG_DVB_TDA10023 is not set
+# CONFIG_DVB_VES1820 is not set
+# CONFIG_DVB_AU8522_DTV is not set
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_BCM3510 is not set
+# CONFIG_DVB_LG2160 is not set
+# CONFIG_DVB_LGDT3305 is not set
+# CONFIG_DVB_LGDT330X is not set
+# CONFIG_DVB_MXL692 is not set
+# CONFIG_DVB_NXT200X is not set
+# CONFIG_DVB_OR51132 is not set
+# CONFIG_DVB_OR51211 is not set
+# CONFIG_DVB_S5H1409 is not set
+# CONFIG_DVB_S5H1411 is not set
+# CONFIG_DVB_DIB8000 is not set
+# CONFIG_DVB_MB86A20S is not set
+# CONFIG_DVB_S921 is not set
+# CONFIG_DVB_MN88443X is not set
+# CONFIG_DVB_TC90522 is not set
+# CONFIG_DVB_PLL is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+# CONFIG_DVB_A8293 is not set
+# CONFIG_DVB_AF9033 is not set
+# CONFIG_DVB_ASCOT2E is not set
+# CONFIG_DVB_ATBM8830 is not set
+# CONFIG_DVB_HELENE is not set
+# CONFIG_DVB_HORUS3A is not set
+# CONFIG_DVB_ISL6405 is not set
+# CONFIG_DVB_ISL6421 is not set
+# CONFIG_DVB_ISL6423 is not set
+# CONFIG_DVB_IX2505V is not set
+# CONFIG_DVB_LGS8GL5 is not set
+# CONFIG_DVB_LGS8GXX is not set
+# CONFIG_DVB_LNBH25 is not set
+# CONFIG_DVB_LNBH29 is not set
+# CONFIG_DVB_LNBP21 is not set
+# CONFIG_DVB_LNBP22 is not set
+# CONFIG_DVB_M88RS2000 is not set
+# CONFIG_DVB_TDA665x is not set
+# CONFIG_DVB_DRX39XYJ is not set
+# CONFIG_DVB_CXD2099 is not set
+# CONFIG_DVB_SP2 is not set
+CONFIG_DRM=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+CONFIG_DRM_ROCKCHIP=y
+# CONFIG_ROCKCHIP_VOP is not set
+CONFIG_ROCKCHIP_VOP2=y
+CONFIG_ROCKCHIP_DW_HDMI=y
+CONFIG_ROCKCHIP_DW_MIPI_DSI=y
+CONFIG_DRM_PANEL_SIMPLE=y
+CONFIG_DRM_DISPLAY_CONNECTOR=y
+CONFIG_DRM_DW_HDMI_I2S_AUDIO=y
+CONFIG_DRM_DW_HDMI_CEC=y
+CONFIG_DRM_PANFROST=y
+CONFIG_FB=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_DYNAMIC_MINORS=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_PCI is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_AUDIO_MIDI_V2=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_ROCKCHIP=y
+CONFIG_SND_SOC_ROCKCHIP_I2S_TDM=y
+CONFIG_SND_SOC_ROCKCHIP_PDM=y
+CONFIG_SND_SOC_ROCKCHIP_SPDIF=y
+CONFIG_SND_SOC_BT_SCO=y
+CONFIG_SND_SOC_ES8328_I2C=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_USB_HIDDEV=y
+# CONFIG_I2C_HID is not set
+CONFIG_USB=y
+# CONFIG_USB_PCI is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_FEW_INIT_RETRIES=y
+CONFIG_USB_OTG=y
+CONFIG_USB_OTG_FSM=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_ONBOARD_HUB=y
+CONFIG_TYPEC=y
+CONFIG_TYPEC_TCPM=y
+CONFIG_TYPEC_TCPCI=y
+CONFIG_TYPEC_FUSB302=y
+CONFIG_TYPEC_MUX_GPIO_SBU=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_DWCMSHC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_ROCKCHIP=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_ACTIVITY=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_RK808=y
+CONFIG_DMADEVICES=y
+CONFIG_PL330_DMA=y
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+CONFIG_DMABUF_HEAPS_CMA=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+CONFIG_COMMON_CLK_SCMI=y
+# CONFIG_CLK_PX30 is not set
+# CONFIG_CLK_RK3308 is not set
+# CONFIG_CLK_RK3328 is not set
+# CONFIG_CLK_RK3368 is not set
+# CONFIG_CLK_RK3399 is not set
+# CONFIG_CLK_RK3588 is not set
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+CONFIG_MAILBOX=y
+CONFIG_ROCKCHIP_MBOX=y
+CONFIG_ROCKCHIP_IOMMU=y
+CONFIG_ARM_SMMU_V3=y
+CONFIG_ROCKCHIP_IODOMAIN=y
+CONFIG_ROCKCHIP_PM_DOMAINS=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER_CB=y
+CONFIG_ROCKCHIP_SARADC=y
+CONFIG_PWM=y
+CONFIG_PWM_ROCKCHIP=y
+CONFIG_PHY_ROCKCHIP_INNO_HDMI=y
+CONFIG_PHY_ROCKCHIP_INNO_USB2=y
+CONFIG_PHY_ROCKCHIP_INNO_CSIDPHY=y
+CONFIG_PHY_ROCKCHIP_INNO_DSIDPHY=y
+CONFIG_PHY_ROCKCHIP_NANENG_COMBO_PHY=y
+CONFIG_PHY_ROCKCHIP_SNPS_PCIE3=y
+CONFIG_PHY_ROCKCHIP_TYPEC=y
+CONFIG_PHY_ROCKCHIP_USB=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_F2FS_FS=y
+# CONFIG_F2FS_STAT_FS is not set
+# CONFIG_F2FS_FS_XATTR is not set
+# CONFIG_F2FS_IOSTAT is not set
+CONFIG_FSCACHE=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=866
+CONFIG_FAT_DEFAULT_IOCHARSET="cp1251"
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_EXFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+# CONFIG_PROC_PAGE_MONITOR is not set
+CONFIG_TMPFS=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_UTF8=y
+CONFIG_LSM="landlock,lockdown,yama,loadpin,safesetid,selinux,smack,tomoyo,apparmor,bpf"
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_HW is not set
+CONFIG_DMA_CMA=y
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_PANIC_TIMEOUT=5
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_FTRACE is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
index 2254457ab5d0..9aeeb63435cd 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
@@ -786,8 +786,13 @@ static void adv7511_mode_set(struct adv7511 *adv7511,
 	else
 		low_refresh_rate = ADV7511_LOW_REFRESH_RATE_NONE;
 
-	regmap_update_bits(adv7511->regmap, 0xfb,
-		0x6, low_refresh_rate << 1);
+	if (adv7511->type == ADV7511)
+		regmap_update_bits(adv7511->regmap, 0xfb,
+				   0x6, low_refresh_rate << 1);
+	else
+		regmap_update_bits(adv7511->regmap, 0x4a,
+				   0xc, low_refresh_rate << 2);
+
 	regmap_update_bits(adv7511->regmap, 0x17,
 		0x60, (vsync_polarity << 6) | (hsync_polarity << 5));
 
diff --git a/drivers/gpu/drm/bridge/samsung-dsim.c b/drivers/gpu/drm/bridge/samsung-dsim.c
index 73ec60757dbc..9e253af69c7a 100644
--- a/drivers/gpu/drm/bridge/samsung-dsim.c
+++ b/drivers/gpu/drm/bridge/samsung-dsim.c
@@ -1009,7 +1009,7 @@ static int samsung_dsim_wait_for_hdr_fifo(struct samsung_dsim *dsi)
 	do {
 		u32 reg = samsung_dsim_read(dsi, DSIM_FIFOCTRL_REG);
 
-		if (!(reg & DSIM_SFR_HEADER_FULL))
+		if (reg & DSIM_SFR_HEADER_EMPTY)
 			return 0;
 
 		if (!cond_resched())
diff --git a/drivers/gpu/drm/mxsfb/mxsfb_kms.c b/drivers/gpu/drm/mxsfb/mxsfb_kms.c
index 3bcc9c0f2019..608d850e4154 100644
--- a/drivers/gpu/drm/mxsfb/mxsfb_kms.c
+++ b/drivers/gpu/drm/mxsfb/mxsfb_kms.c
@@ -70,8 +70,9 @@ static void mxsfb_set_formats(struct mxsfb_drm_private *mxsfb,
 		ctrl |= CTRL_WORD_LENGTH_16;
 		ctrl1 |= CTRL1_SET_BYTE_PACKAGING(0xf);
 		break;
+	case DRM_FORMAT_ARGB8888:
 	case DRM_FORMAT_XRGB8888:
-		dev_dbg(drm->dev, "Setting up XRGB8888 mode\n");
+		dev_dbg(drm->dev, "Setting up xRGB8888 mode\n");
 		ctrl |= CTRL_WORD_LENGTH_24;
 		/* Do not use packed pixels = one pixel per word instead. */
 		ctrl1 |= CTRL1_SET_BYTE_PACKAGING(0x7);
@@ -641,6 +642,7 @@ static const struct drm_plane_funcs mxsfb_plane_funcs = {
 static const uint32_t mxsfb_primary_plane_formats[] = {
 	DRM_FORMAT_RGB565,
 	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ARGB8888,
 };
 
 static const uint32_t mxsfb_overlay_plane_formats[] = {
diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index 36b509714c8c..8b7ff2f3bdda 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -568,9 +568,7 @@ static const struct reg_value ov5640_init_setting[] = {
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
 	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
 	{0x302e, 0x08, 0, 0}, {0x4300, 0x3f, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x440e, 0x00, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x4837, 0x0a, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x501f, 0x00, 0, 0}, {0x440e, 0x00, 0, 0}, {0x4837, 0x0a, 0, 0},
 	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
 	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
 	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
@@ -634,7 +632,8 @@ static const struct reg_value ov5640_setting_low_res[] = {
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
+	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_720P_1280_720[] = {
@@ -2453,16 +2452,13 @@ static void ov5640_power(struct ov5640_dev *sensor, bool enable)
 static void ov5640_powerup_sequence(struct ov5640_dev *sensor)
 {
 	if (sensor->pwdn_gpio) {
-		gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+		gpiod_set_value_cansleep(sensor->reset_gpio, 1);
 
 		/* camera power cycle */
 		ov5640_power(sensor, false);
-		usleep_range(5000, 10000);
+		usleep_range(5000, 10000);	/* t2 */
 		ov5640_power(sensor, true);
-		usleep_range(5000, 10000);
-
-		gpiod_set_value_cansleep(sensor->reset_gpio, 1);
-		usleep_range(1000, 2000);
+		usleep_range(1000, 2000);	/* t3 */
 
 		gpiod_set_value_cansleep(sensor->reset_gpio, 0);
 	} else {
@@ -2470,7 +2466,7 @@ static void ov5640_powerup_sequence(struct ov5640_dev *sensor)
 		ov5640_write_reg(sensor, OV5640_REG_SYS_CTRL0,
 				 OV5640_REG_SYS_CTRL0_SW_RST);
 	}
-	usleep_range(20000, 25000);
+	usleep_range(20000, 25000);	/* t4 */
 
 	/*
 	 * software standby: allows registers programming;
@@ -2543,9 +2539,9 @@ static int ov5640_set_power_mipi(struct ov5640_dev *sensor, bool on)
 	 *		  "ov5640_set_stream_mipi()")
 	 * [4] = 0	: Power up MIPI HS Tx
 	 * [3] = 0	: Power up MIPI LS Rx
-	 * [2] = 0	: MIPI interface disabled
+	 * [2] = 1	: MIPI interface enabled
 	 */
-	ret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x40);
+	ret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x44);
 	if (ret)
 		return ret;
 
diff --git a/drivers/media/platform/nxp/imx-mipi-csis.c b/drivers/media/platform/nxp/imx-mipi-csis.c
index 05d52762e792..4780f5654d76 100644
--- a/drivers/media/platform/nxp/imx-mipi-csis.c
+++ b/drivers/media/platform/nxp/imx-mipi-csis.c
@@ -596,6 +596,9 @@ static int mipi_csis_calculate_params(struct mipi_csis_device *csis,
 	s64 link_freq;
 	u32 lane_rate;
 
+	if (!csis->src_sd)
+		return -EINVAL;
+
 	/* Calculate the line rate from the pixel rate. */
 	link_freq = v4l2_get_link_freq(csis->src_sd->ctrl_handler,
 				       csis_fmt->width,
diff --git a/drivers/media/platform/nxp/imx7-media-csi.c b/drivers/media/platform/nxp/imx7-media-csi.c
index 791bde67f439..8af71c89f8dc 100644
--- a/drivers/media/platform/nxp/imx7-media-csi.c
+++ b/drivers/media/platform/nxp/imx7-media-csi.c
@@ -1076,6 +1076,7 @@ static int imx7_csi_video_enum_framesizes(struct file *file, void *fh,
 					  struct v4l2_frmsizeenum *fsize)
 {
 	const struct imx7_csi_pixfmt *cc;
+	u32 walign;
 
 	if (fsize->index > 0)
 		return -EINVAL;
@@ -1085,16 +1086,17 @@ static int imx7_csi_video_enum_framesizes(struct file *file, void *fh,
 		return -EINVAL;
 
 	/*
-	 * TODO: The constraints are hardware-specific and may depend on the
-	 * pixel format. This should come from the driver using
-	 * imx_media_capture.
+	 * The width alignment is 8 bytes as indicated by the
+	 * CSI_IMAG_PARA.IMAGE_WIDTH documentation. Convert it to pixels.
 	 */
+	walign = 8 * 8 / cc->bpp;
+
 	fsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
-	fsize->stepwise.min_width = 1;
-	fsize->stepwise.max_width = 65535;
+	fsize->stepwise.min_width = walign;
+	fsize->stepwise.max_width = round_down(65535U, walign);
 	fsize->stepwise.min_height = 1;
 	fsize->stepwise.max_height = 65535;
-	fsize->stepwise.step_width = 1;
+	fsize->stepwise.step_width = walign;
 	fsize->stepwise.step_height = 1;
 
 	return 0;
diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
index a5c5036dfb94..4396f3c3c114 100644
--- a/drivers/net/can/Kconfig
+++ b/drivers/net/can/Kconfig
@@ -217,6 +217,7 @@ source "drivers/net/can/m_can/Kconfig"
 source "drivers/net/can/mscan/Kconfig"
 source "drivers/net/can/peak_canfd/Kconfig"
 source "drivers/net/can/rcar/Kconfig"
+source "drivers/net/can/rockchip/Kconfig"
 source "drivers/net/can/sja1000/Kconfig"
 source "drivers/net/can/softing/Kconfig"
 source "drivers/net/can/spi/Kconfig"
diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
index ff8f76295d13..5140da19fc95 100644
--- a/drivers/net/can/Makefile
+++ b/drivers/net/can/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_CAN_SLCAN)		+= slcan/
 
 obj-y				+= dev/
 obj-y				+= rcar/
+obj-y				+= rockchip/
 obj-y				+= spi/
 obj-y				+= usb/
 obj-y				+= softing/
diff --git a/drivers/net/can/rockchip/Kconfig b/drivers/net/can/rockchip/Kconfig
new file mode 100644
index 000000000000..775ff80d9a81
--- /dev/null
+++ b/drivers/net/can/rockchip/Kconfig
@@ -0,0 +1,8 @@
+config CANFD_ROCKCHIP
+	tristate "Rockchip CANFD controller"
+	depends on ARCH_ROCKCHIP
+	help
+	  Say Y here if you want to use CANFD controller found on Rockchip SoCs.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called rockchip_canfd.
diff --git a/drivers/net/can/rockchip/Makefile b/drivers/net/can/rockchip/Makefile
new file mode 100644
index 000000000000..1619d4dcfc6d
--- /dev/null
+++ b/drivers/net/can/rockchip/Makefile
@@ -0,0 +1,5 @@
+#
+#  Makefile for the rockchip can and canfd controller driver.
+#
+
+obj-$(CONFIG_CANFD_ROCKCHIP)	+= rockchip_canfd.o
diff --git a/drivers/net/can/rockchip/rockchip_canfd.c b/drivers/net/can/rockchip/rockchip_canfd.c
new file mode 100644
index 000000000000..287b73893b39
--- /dev/null
+++ b/drivers/net/can/rockchip/rockchip_canfd.c
@@ -0,0 +1,1078 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co. Ltd.
+ * Rockchip CANFD driver
+ */
+
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/clk.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/can/dev.h>
+#include <linux/can/error.h>
+#include <linux/reset.h>
+#include <linux/pm_runtime.h>
+
+/* registers definition */
+enum rockchip_canfd_reg {
+	CAN_MODE = 0x00,
+	CAN_CMD = 0x04,
+	CAN_STATE = 0x08,
+	CAN_INT = 0x0c,
+	CAN_INT_MASK = 0x10,
+	CAN_LOSTARB_CODE = 0x28,
+	CAN_ERR_CODE = 0x2c,
+	CAN_RX_ERR_CNT = 0x34,
+	CAN_TX_ERR_CNT = 0x38,
+	CAN_IDCODE = 0x3c,
+	CAN_IDMASK = 0x40,
+	CAN_NBTP = 0x100,
+	CAN_DBTP = 0x104,
+	CAN_TDCR = 0x108,
+	CAN_TSCC = 0x10c,
+	CAN_TSCV = 0x110,
+	CAN_TXEFC = 0x114,
+	CAN_RXFC = 0x118,
+	CAN_AFC = 0x11c,
+	CAN_IDCODE0 = 0x120,
+	CAN_IDMASK0 = 0x124,
+	CAN_IDCODE1 = 0x128,
+	CAN_IDMASK1 = 0x12c,
+	CAN_IDCODE2 = 0x130,
+	CAN_IDMASK2 = 0x134,
+	CAN_IDCODE3 = 0x138,
+	CAN_IDMASK3 = 0x13c,
+	CAN_IDCODE4 = 0x140,
+	CAN_IDMASK4 = 0x144,
+	CAN_TXFIC = 0x200,
+	CAN_TXID = 0x204,
+	CAN_TXDAT0 = 0x208,
+	CAN_TXDAT1 = 0x20c,
+	CAN_TXDAT2 = 0x210,
+	CAN_TXDAT3 = 0x214,
+	CAN_TXDAT4 = 0x218,
+	CAN_TXDAT5 = 0x21c,
+	CAN_TXDAT6 = 0x220,
+	CAN_TXDAT7 = 0x224,
+	CAN_TXDAT8 = 0x228,
+	CAN_TXDAT9 = 0x22c,
+	CAN_TXDAT10 = 0x230,
+	CAN_TXDAT11 = 0x234,
+	CAN_TXDAT12 = 0x238,
+	CAN_TXDAT13 = 0x23c,
+	CAN_TXDAT14 = 0x240,
+	CAN_TXDAT15 = 0x244,
+	CAN_RXFIC = 0x300,
+	CAN_RXID = 0x304,
+	CAN_RXTS = 0x308,
+	CAN_RXDAT0 = 0x30c,
+	CAN_RXDAT1 = 0x310,
+	CAN_RXDAT2 = 0x314,
+	CAN_RXDAT3 = 0x318,
+	CAN_RXDAT4 = 0x31c,
+	CAN_RXDAT5 = 0x320,
+	CAN_RXDAT6 = 0x324,
+	CAN_RXDAT7 = 0x328,
+	CAN_RXDAT8 = 0x32c,
+	CAN_RXDAT9 = 0x330,
+	CAN_RXDAT10 = 0x334,
+	CAN_RXDAT11 = 0x338,
+	CAN_RXDAT12 = 0x33c,
+	CAN_RXDAT13 = 0x340,
+	CAN_RXDAT14 = 0x344,
+	CAN_RXDAT15 = 0x348,
+	CAN_RXFRD = 0x400,
+	CAN_TXEFRD = 0x500,
+};
+
+#define DATE_LENGTH_12_BYTE	(0x9)
+#define DATE_LENGTH_16_BYTE	(0xa)
+#define DATE_LENGTH_20_BYTE	(0xb)
+#define DATE_LENGTH_24_BYTE	(0xc)
+#define DATE_LENGTH_32_BYTE	(0xd)
+#define DATE_LENGTH_48_BYTE	(0xe)
+#define DATE_LENGTH_64_BYTE	(0xf)
+
+#define CAN_TX0_REQ		BIT(0)
+#define CAN_TX1_REQ		BIT(1)
+#define CAN_TX_REQ_FULL		((CAN_TX0_REQ) | (CAN_TX1_REQ))
+
+#define MODE_FDOE		BIT(15)
+#define MODE_BRSD		BIT(13)
+#define MODE_SPACE_RX		BIT(12)
+#define MODE_AUTO_RETX		BIT(10)
+#define MODE_RXSORT		BIT(7)
+#define MODE_TXORDER		BIT(6)
+#define MODE_RXSTX		BIT(5)
+#define MODE_LBACK		BIT(4)
+#define MODE_SILENT		BIT(3)
+#define MODE_SELF_TEST		BIT(2)
+#define MODE_SLEEP		BIT(1)
+#define RESET_MODE		0
+#define WORK_MODE		BIT(0)
+
+#define RX_PERIOD		BIT(2)
+
+#define RX_FINISH_INT		BIT(0)
+#define TX_FINISH_INT		BIT(1)
+#define ERR_WARN_INT		BIT(2)
+#define RX_BUF_OV_INT		BIT(3)
+#define PASSIVE_ERR_INT		BIT(4)
+#define TX_LOSTARB_INT		BIT(5)
+#define BUS_ERR_INT		BIT(6)
+#define RX_FIFO_FULL_INT	BIT(7)
+#define RX_FIFO_OV_INT		BIT(8)
+#define BUS_OFF_INT		BIT(9)
+#define BUS_OFF_RECOVERY_INT	BIT(10)
+#define TSC_OV_INT		BIT(11)
+#define TXE_FIFO_OV_INT		BIT(12)
+#define TXE_FIFO_FULL_INT	BIT(13)
+#define WAKEUP_INT		BIT(14)
+
+#define ERR_TYPE_MASK		GENMASK(28, 26)
+#define ERR_TYPE_SHIFT		26
+#define BIT_ERR			0
+#define STUFF_ERR		1
+#define FORM_ERR		2
+#define ACK_ERR			3
+#define CRC_ERR			4
+#define ERR_DIR_RX		BIT(25)
+#define ERR_LOC_MASK		GENMASK(15, 0)
+
+/* Nominal Bit Timing & Prescaler Register (NBTP) */
+#define NBTP_MODE_3_SAMPLES	BIT(31)
+#define NBTP_NSJW_SHIFT		24
+#define NBTP_NSJW_MASK		(0x7f << NBTP_NSJW_SHIFT)
+#define NBTP_NBRP_SHIFT		16
+#define NBTP_NBRP_MASK		(0xff << NBTP_NBRP_SHIFT)
+#define NBTP_NTSEG2_SHIFT	8
+#define NBTP_NTSEG2_MASK	(0x7f << NBTP_NTSEG2_SHIFT)
+#define NBTP_NTSEG1_SHIFT	0
+#define NBTP_NTSEG1_MASK	(0x7f << NBTP_NTSEG1_SHIFT)
+
+/* Data Bit Timing & Prescaler Register (DBTP) */
+#define DBTP_MODE_3_SAMPLES	BIT(21)
+#define DBTP_DSJW_SHIFT		17
+#define DBTP_DSJW_MASK		(0xf << DBTP_DSJW_SHIFT)
+#define DBTP_DBRP_SHIFT		9
+#define DBTP_DBRP_MASK		(0xff << DBTP_DBRP_SHIFT)
+#define DBTP_DTSEG2_SHIFT	5
+#define DBTP_DTSEG2_MASK	(0xf << DBTP_DTSEG2_SHIFT)
+#define DBTP_DTSEG1_SHIFT	0
+#define DBTP_DTSEG1_MASK	(0x1f << DBTP_DTSEG1_SHIFT)
+
+/* Transmitter Delay Compensation Register (TDCR) */
+#define TDCR_TDCO_SHIFT		1
+#define TDCR_TDCO_MASK		(0x3f << TDCR_TDCO_SHIFT)
+#define TDCR_TDC_ENABLE		BIT(0)
+
+#define TX_FD_ENABLE		BIT(5)
+#define TX_FD_BRS_ENABLE	BIT(4)
+
+#define FIFO_ENABLE		BIT(0)
+
+#define FORMAT_SHIFT		7
+#define FORMAT_MASK		(0x1 << FORMAT_SHIFT)
+#define RTR_SHIFT		6
+#define RTR_MASK		(0x1 << RTR_SHIFT)
+#define FDF_SHIFT		5
+#define FDF_MASK		(0x1 << FDF_SHIFT)
+#define BRS_SHIFT		4
+#define BRS_MASK		(0x1 << BRS_SHIFT)
+#define DLC_SHIFT		0
+#define DLC_MASK		(0xF << DLC_SHIFT)
+
+#define CAN_RF_SIZE		0x48
+#define CAN_TEF_SIZE		0x8
+#define CAN_TXEFRD_OFFSET(n)	(CAN_TXEFRD + CAN_TEF_SIZE * (n))
+#define CAN_RXFRD_OFFSET(n)	(CAN_RXFRD + CAN_RF_SIZE * (n))
+
+#define CAN_RX_FILTER_MASK	0x1fffffff
+
+#define DRV_NAME	"rockchip_canfd"
+
+/* rockchip_canfd private data structure */
+
+struct rockchip_canfd {
+	struct can_priv can;
+	struct device *dev;
+	spinlock_t tx_lock;
+	struct napi_struct napi;
+	struct clk_bulk_data *clks;
+	int num_clks;
+	struct reset_control *reset;
+	void __iomem *base;
+	u32 irqstatus;
+	u32 data[120];
+};
+
+static inline u32 rockchip_canfd_read(const struct rockchip_canfd *priv,
+				      enum rockchip_canfd_reg reg)
+{
+	return readl(priv->base + reg);
+}
+
+static inline void rockchip_canfd_write(const struct rockchip_canfd *priv,
+					enum rockchip_canfd_reg reg, u32 val)
+{
+	writel(val, priv->base + reg);
+}
+
+static const struct can_bittiming_const rockchip_canfd_bittiming_const = {
+	.name = DRV_NAME,
+	.tseg1_min = 1,
+	.tseg1_max = 128,
+	.tseg2_min = 1,
+	.tseg2_max = 128,
+	.sjw_max = 128,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 2,
+};
+
+static const struct can_bittiming_const rockchip_canfd_data_bittiming_const = {
+	.name = DRV_NAME,
+	.tseg1_min = 1,
+	.tseg1_max = 32,
+	.tseg2_min = 1,
+	.tseg2_max = 16,
+	.sjw_max = 16,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 2,
+};
+
+static int set_reset_mode(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+
+	reset_control_assert(rcan->reset);
+	udelay(2);
+	reset_control_deassert(rcan->reset);
+
+	rockchip_canfd_write(rcan, CAN_MODE, 0);
+
+	netdev_dbg(ndev, "%s MODE=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_MODE));
+
+	return 0;
+}
+
+static int set_normal_mode(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	u32 val;
+
+	val = rockchip_canfd_read(rcan, CAN_MODE);
+	val |= WORK_MODE;
+	rockchip_canfd_write(rcan, CAN_MODE, val);
+
+	netdev_dbg(ndev, "%s MODE=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_MODE));
+	return 0;
+}
+
+/* bittiming is called in reset_mode only */
+static int rockchip_canfd_set_bittiming(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	const struct can_bittiming *bt = &rcan->can.bittiming;
+	const struct can_bittiming *dbt = &rcan->can.data_bittiming;
+	u16 brp, sjw, tseg1, tseg2;
+	u32 reg_btp;
+
+	brp = (bt->brp >> 1) - 1;
+	sjw = bt->sjw - 1;
+	tseg1 = bt->prop_seg + bt->phase_seg1 - 1;
+	tseg2 = bt->phase_seg2 - 1;
+	reg_btp = (brp << NBTP_NBRP_SHIFT) | (sjw << NBTP_NSJW_SHIFT) |
+		  (tseg1 << NBTP_NTSEG1_SHIFT) |
+		  (tseg2 << NBTP_NTSEG2_SHIFT);
+
+	if (rcan->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)
+		reg_btp |= NBTP_MODE_3_SAMPLES;
+
+	rockchip_canfd_write(rcan, CAN_NBTP, reg_btp);
+
+	if (rcan->can.ctrlmode & CAN_CTRLMODE_FD) {
+		reg_btp = 0;
+		brp = (dbt->brp >> 1) - 1;
+		sjw = dbt->sjw - 1;
+		tseg1 = dbt->prop_seg + dbt->phase_seg1 - 1;
+		tseg2 = dbt->phase_seg2 - 1;
+
+		if (dbt->bitrate > 2200000) {
+			u32 tdco;
+
+			/* Equation based on Bosch's ROCKCHIP_CAN User Manual's
+			 * Transmitter Delay Compensation Section
+			 */
+			tdco = (rcan->can.clock.freq / dbt->bitrate) * 2 / 3;
+			/* Max valid TDCO value is 63 */
+			if (tdco > 63)
+				tdco = 63;
+
+			rockchip_canfd_write(rcan, CAN_TDCR,
+					     (tdco << TDCR_TDCO_SHIFT) |
+					     TDCR_TDC_ENABLE);
+		}
+
+		reg_btp |= (brp << DBTP_DBRP_SHIFT) |
+			   (sjw << DBTP_DSJW_SHIFT) |
+			   (tseg1 << DBTP_DTSEG1_SHIFT) |
+			   (tseg2 << DBTP_DTSEG2_SHIFT);
+
+		if (rcan->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)
+			reg_btp |= DBTP_MODE_3_SAMPLES;
+
+		rockchip_canfd_write(rcan, CAN_DBTP, reg_btp);
+	}
+
+	netdev_dbg(ndev, "%s NBTP=0x%08x, DBTP=0x%08x, TDCR=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_NBTP),
+		   rockchip_canfd_read(rcan, CAN_DBTP),
+		   rockchip_canfd_read(rcan, CAN_TDCR));
+	return 0;
+}
+
+static int rockchip_canfd_get_berr_counter(const struct net_device *ndev,
+					   struct can_berr_counter *bec)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	int err;
+
+	err = pm_runtime_get_sync(rcan->dev);
+	if (err < 0) {
+		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
+			   __func__, err);
+		return err;
+	}
+
+	bec->rxerr = rockchip_canfd_read(rcan, CAN_RX_ERR_CNT);
+	bec->txerr = rockchip_canfd_read(rcan, CAN_TX_ERR_CNT);
+
+	pm_runtime_put(rcan->dev);
+
+	netdev_dbg(ndev, "%s RX_ERR_CNT=0x%08x, TX_ERR_CNT=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_RX_ERR_CNT),
+		   rockchip_canfd_read(rcan, CAN_TX_ERR_CNT));
+
+	return 0;
+}
+
+static int rockchip_canfd_start(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	u32 val;
+
+	/* we need to enter the reset mode */
+	set_reset_mode(ndev);
+
+	rockchip_canfd_write(rcan, CAN_INT_MASK, 0);
+
+	/* RECEIVING FILTER, accept all */
+	rockchip_canfd_write(rcan, CAN_IDCODE, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK, CAN_RX_FILTER_MASK);
+	rockchip_canfd_write(rcan, CAN_IDCODE0, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK0, CAN_RX_FILTER_MASK);
+	rockchip_canfd_write(rcan, CAN_IDCODE1, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK1, CAN_RX_FILTER_MASK);
+	rockchip_canfd_write(rcan, CAN_IDCODE2, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK2, CAN_RX_FILTER_MASK);
+	rockchip_canfd_write(rcan, CAN_IDCODE3, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK3, CAN_RX_FILTER_MASK);
+	rockchip_canfd_write(rcan, CAN_IDCODE4, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK4, CAN_RX_FILTER_MASK);
+
+	/* set mode */
+	val = rockchip_canfd_read(rcan, CAN_MODE);
+
+	/* rx fifo enable */
+	rockchip_canfd_write(rcan, CAN_RXFC,
+			     rockchip_canfd_read(rcan, CAN_RXFC) | FIFO_ENABLE);
+
+	/* Canfd Mode */
+	if (rcan->can.ctrlmode & CAN_CTRLMODE_FD) {
+		val |= MODE_FDOE;
+		rockchip_canfd_write(rcan, CAN_TXFIC,
+				     rockchip_canfd_read(rcan, CAN_TXFIC) |
+				     TX_FD_ENABLE);
+	}
+
+	/* Loopback Mode */
+	if (rcan->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)
+		val |= MODE_SELF_TEST | MODE_LBACK;
+
+	val |= MODE_AUTO_RETX;
+
+	rockchip_canfd_write(rcan, CAN_MODE, val);
+
+	rockchip_canfd_set_bittiming(ndev);
+
+	set_normal_mode(ndev);
+
+	rcan->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	netdev_dbg(ndev, "%s MODE=0x%08x, INT_MASK=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_MODE),
+		   rockchip_canfd_read(rcan, CAN_INT_MASK));
+
+	return 0;
+}
+
+static int rockchip_canfd_stop(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+
+	rcan->can.state = CAN_STATE_STOPPED;
+	/* we need to enter reset mode */
+	set_reset_mode(ndev);
+
+	/* disable all interrupts */
+	rockchip_canfd_write(rcan, CAN_INT_MASK, 0xffff);
+
+	netdev_dbg(ndev, "%s MODE=0x%08x, INT_MASK=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_MODE),
+		   rockchip_canfd_read(rcan, CAN_INT_MASK));
+	return 0;
+}
+
+static int rockchip_canfd_set_mode(struct net_device *ndev,
+				   enum can_mode mode)
+{
+	int err;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		err = rockchip_canfd_start(ndev);
+		if (err) {
+			netdev_err(ndev, "starting CAN controller failed!\n");
+			return err;
+		}
+		if (netif_queue_stopped(ndev))
+			netif_wake_queue(ndev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+/* transmit a CAN message
+ * message layout in the sk_buff should be like this:
+ * xx xx xx xx         ff         ll 00 11 22 33 44 55 66 77
+ * [ can_id ] [flags] [len] [can data (up to 8 bytes]
+ */
+static int rockchip_canfd_start_xmit(struct sk_buff *skb,
+				     struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	struct canfd_frame *cf = (struct canfd_frame *)skb->data;
+	u32 id, dlc;
+	u32 cmd = CAN_TX0_REQ, mode;
+	int i;
+//	unsigned long flags;
+
+	if (can_dropped_invalid_skb(ndev, skb))
+		return NETDEV_TX_OK;
+
+//	spin_lock_irqsave(&rcan->tx_lock, flags);
+	can_put_echo_skb(skb, ndev, 0, 0);
+
+	netif_stop_queue(ndev);
+
+	if (rockchip_canfd_read(rcan, CAN_CMD) & CAN_TX0_REQ)
+		cmd = CAN_TX1_REQ;
+
+	/* Watch carefully on the bit sequence */
+	if (cf->can_id & CAN_EFF_FLAG) {
+		/* Extended CAN ID format */
+		id = cf->can_id & CAN_EFF_MASK;
+		dlc = can_fd_len2dlc(cf->len) & DLC_MASK;
+		dlc |= FORMAT_MASK;
+		/* Extended frames need workround */
+		if ((rockchip_canfd_read(rcan, CAN_STATE) & RX_PERIOD) == 0) {
+			mode = rockchip_canfd_read(rcan, CAN_MODE);
+			rockchip_canfd_write(rcan, CAN_MODE,
+					     mode | MODE_SLEEP);
+			mode = rockchip_canfd_read(rcan, CAN_MODE);
+			rockchip_canfd_write(rcan, CAN_MODE,
+					     mode & (~MODE_SLEEP));
+		}
+		/* Extended frames remote TX request */
+		if (cf->can_id & CAN_RTR_FLAG)
+			dlc |= RTR_MASK;
+	} else {
+		/* Standard CAN ID format */
+		id = cf->can_id & CAN_SFF_MASK;
+		dlc = can_fd_len2dlc(cf->len) & DLC_MASK;
+
+		/* Standard frames remote TX request */
+		if (cf->can_id & CAN_RTR_FLAG)
+			dlc |= RTR_MASK;
+	}
+
+	if ((rcan->can.ctrlmode & CAN_CTRLMODE_FD) && can_is_canfd_skb(skb)) {
+		dlc |= TX_FD_ENABLE;
+		if (cf->flags & CANFD_BRS)
+			dlc |= TX_FD_BRS_ENABLE;
+	}
+
+	rockchip_canfd_write(rcan, CAN_TXID, id);
+	rockchip_canfd_write(rcan, CAN_TXFIC, dlc);
+
+	for (i = 0; i < cf->len; i += 4)
+		rockchip_canfd_write(rcan, CAN_TXDAT0 + i,
+				     *(u32 *)(cf->data + i));
+
+	rockchip_canfd_write(rcan, CAN_CMD, cmd);
+
+	//can_put_echo_skb(skb, ndev, 0);
+
+//	spin_unlock_irqrestore(&rcan->tx_lock, flags);
+
+	return NETDEV_TX_OK;
+}
+
+static int rockchip_canfd_rx(struct net_device *ndev, int frame)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	struct net_device_stats *stats = &ndev->stats;
+	struct canfd_frame *cf;
+	struct sk_buff *skb;
+	u32 id_rockchip_canfd, dlc;
+	int i = 0;
+	u32 __maybe_unused ts, ret;
+	u32 data[16] = {0};
+//	unsigned long flags;
+
+//	spin_lock_irqsave(&rcan->tx_lock, flags);
+
+#if 1
+	dlc = rcan->data[frame * 18];
+	id_rockchip_canfd = rcan->data[frame * 18 + 1];
+	ts = rcan->data[frame * 18 + 2];
+	for (i = 0; i < 16; i++)
+		data[i] = rcan->data[frame * 18 + i + 3];
+#else
+	dlc = rockchip_canfd_read(rcan, CAN_RXFRD);;
+	id_rockchip_canfd = rockchip_canfd_read(rcan, CAN_RXFRD);;
+	ts = rockchip_canfd_read(rcan, CAN_RXFRD);;
+	for (i = 0; i < 16; i++)
+		data[i] = rockchip_canfd_read(rcan, CAN_RXFRD);;
+#endif
+	/* create zero'ed CAN frame buffer */
+	if (dlc & FDF_MASK)
+		skb = alloc_canfd_skb(ndev, &cf);
+	else
+		skb = alloc_can_skb(ndev, (struct can_frame **)&cf);
+	if (!skb) {
+		stats->rx_dropped++;
+		//spin_unlock_irqrestore(&rcan->tx_lock, flags);
+		return 0;
+	}
+
+	/* Change CAN data length format to socketCAN data format */
+	if (dlc & FDF_MASK)
+		cf->len = can_fd_dlc2len(dlc & DLC_MASK);
+	else
+		cf->len = can_fd_dlc2len(dlc & DLC_MASK);
+
+	/* Change CAN ID format to socketCAN ID format */
+	if (dlc & FORMAT_MASK) {
+		/* The received frame is an Extended format frame */
+		cf->can_id = id_rockchip_canfd;
+		cf->can_id |= CAN_EFF_FLAG;
+		if (dlc & RTR_MASK)
+			cf->can_id |= CAN_RTR_FLAG;
+	} else {
+		/* The received frame is a standard format frame */
+		cf->can_id = id_rockchip_canfd;
+		if (dlc & RTR_MASK)
+			cf->can_id |= CAN_RTR_FLAG;
+	}
+
+	if (dlc & BRS_MASK)
+		cf->flags |= CANFD_BRS;
+
+	if (!(cf->can_id & CAN_RTR_FLAG)) {
+		/* Change CAN data format to socketCAN data format */
+		for (i = 0; i < cf->len; i += 4)
+			*(u32 *)(cf->data + i) = data[i / 4];
+	}
+
+	stats->rx_packets++;
+	stats->rx_bytes += cf->len;
+	netif_rx(skb);
+
+//	spin_unlock_irqrestore(&rcan->tx_lock, flags);
+
+	return 1;
+}
+/**
+ * rockchip_canfd_rx_poll - Poll routine for rx packets (NAPI)
+ * @napi:	napi structure pointer
+ * @quota:	Max number of rx packets to be processed.
+ *
+ * This is the poll routine for rx part.
+ * It will process the packets maximux quota value.
+ *
+ * Return: number of packets received
+ */
+static int  rockchip_canfd_rx_poll(struct napi_struct *napi, int quota)
+{
+	struct net_device *ndev = napi->dev;
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	int work_done = 0, i = 0;
+	int frame = 0;
+
+	quota = (rockchip_canfd_read(rcan, 0x118) & 0x70) >> 4;
+
+	for (frame = 0; frame < quota; frame++) {
+		rcan->data[frame * 18] = rockchip_canfd_read(rcan, CAN_RXFRD);
+		rcan->data[frame * 18 + 1] = rockchip_canfd_read(rcan, CAN_RXFRD);
+		rcan->data[frame * 18 + 2] = rockchip_canfd_read(rcan, CAN_RXFRD);
+		for (i = 0; i < 16; i++)
+				rcan->data[frame * 18 + i + 3] = rockchip_canfd_read(rcan, CAN_RXFRD);
+	}
+
+	while (work_done < quota) {
+		work_done += rockchip_canfd_rx(ndev, work_done);
+	}
+
+	for (frame = 0; frame < quota; frame++) {
+		rcan->data[frame * 18] = 0;
+		rcan->data[frame * 18 + 1] = 0;
+		rcan->data[frame * 18 + 2] = 0;
+		for (i = 0; i < 16; i++)
+				rcan->data[frame * 18 + i + 3] = 0;
+	}
+
+	if (work_done < 6) {
+		napi_complete_done(napi, work_done);
+	}
+	return work_done;
+}
+
+int zq_test = 0;
+static int rockchip_canfd_err(struct net_device *ndev, u8 isr)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	struct net_device_stats *stats = &ndev->stats;
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	unsigned int rxerr, txerr;
+	u32 sta_reg;
+	
+	skb = alloc_can_err_skb(ndev, &cf);
+
+	rxerr = rockchip_canfd_read(rcan, CAN_RX_ERR_CNT);
+	txerr = rockchip_canfd_read(rcan, CAN_TX_ERR_CNT);
+	sta_reg = rockchip_canfd_read(rcan, CAN_STATE);
+	
+	if (skb) {
+		cf->data[6] = txerr;
+		cf->data[7] = rxerr;
+	}
+
+	if (isr & BUS_OFF_INT) {
+		rcan->can.state = CAN_STATE_BUS_OFF;
+		rcan->can.can_stats.bus_off++;
+		cf->can_id |= CAN_ERR_BUSOFF;
+	} else if (isr & ERR_WARN_INT) {
+		rcan->can.can_stats.error_warning++;
+		rcan->can.state = CAN_STATE_ERROR_WARNING;
+		/* error warning state */
+		if (likely(skb)) {
+			cf->can_id |= CAN_ERR_CRTL;
+			cf->data[1] = (txerr > rxerr) ?
+				CAN_ERR_CRTL_TX_WARNING :
+				CAN_ERR_CRTL_RX_WARNING;
+			cf->data[6] = txerr;
+			cf->data[7] = rxerr;
+		}
+	} else if (isr & PASSIVE_ERR_INT) {
+		rcan->can.can_stats.error_passive++;
+		rcan->can.state = CAN_STATE_ERROR_PASSIVE;
+		/* error passive state */
+		cf->can_id |= CAN_ERR_CRTL;
+		cf->data[1] = (txerr > rxerr) ?
+					CAN_ERR_CRTL_TX_WARNING :
+					CAN_ERR_CRTL_RX_WARNING;
+		cf->data[6] = txerr;
+		cf->data[7] = rxerr;
+	}
+
+	if ((rcan->can.state >= CAN_STATE_BUS_OFF) || ((sta_reg & 0x20) == 0x20)) {
+		zq_test++;
+		can_bus_off(ndev);
+	}
+
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+	netif_receive_skb(skb);
+
+	return 0;
+}
+
+static irqreturn_t rockchip_canfd_interrupt(int irq, void *dev_id)
+{
+	struct net_device *ndev = (struct net_device *)dev_id;
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	struct net_device_stats *stats = &ndev->stats;
+	u8 err_int = ERR_WARN_INT | RX_BUF_OV_INT | PASSIVE_ERR_INT |
+		     TX_LOSTARB_INT | BUS_ERR_INT;
+	u8 isr;
+	u32 dlc = 0;
+	u32 frame, quota = 0;
+	int i = 0;
+	//unsigned long flags;
+
+	isr = rockchip_canfd_read(rcan, CAN_INT);
+	if (isr & RX_FINISH_INT) {
+		#if 1
+		quota = (rockchip_canfd_read(rcan, 0x118) & 0x70) >> 4;
+
+		for (frame = 0; frame < quota; frame++) {
+			rcan->data[frame * 18] = rockchip_canfd_read(rcan, CAN_RXFRD);
+			rcan->data[frame * 18 + 1] = rockchip_canfd_read(rcan, CAN_RXFRD);
+			rcan->data[frame * 18 + 2] = rockchip_canfd_read(rcan, CAN_RXFRD);
+			for (i = 0; i < 16; i++)
+					rcan->data[frame * 18 + i + 3] = rockchip_canfd_read(rcan, CAN_RXFRD);
+		}
+		for (i = 0; i < quota; i++) {
+			rockchip_canfd_rx(ndev, i);
+		}
+		for (frame = 0; frame < quota; frame++) {
+			rcan->data[frame * 18] = 0;
+			rcan->data[frame * 18 + 1] = 0;
+			rcan->data[frame * 18 + 2] = 0;
+			for (i = 0; i < 16; i++)
+					rcan->data[frame * 18 + i + 3] = 0;
+		}
+		#else
+		napi_schedule(&rcan->napi);
+		#endif
+	}
+
+	if (isr & TX_FINISH_INT) {
+		dlc = rockchip_canfd_read(rcan, CAN_TXFIC);
+		/* transmission complete interrupt */
+		if (dlc & FDF_MASK)
+			stats->tx_bytes += can_fd_dlc2len(dlc & DLC_MASK);
+		else
+			stats->tx_bytes += (dlc & DLC_MASK);
+		stats->tx_packets++;
+	//	spin_lock_irqsave(&rcan->tx_lock, flags);
+		can_get_echo_skb(ndev, 0, 0);
+		netif_wake_queue(ndev);
+	//	spin_unlock_irqrestore(&rcan->tx_lock, flags);
+	}
+
+	isr = rockchip_canfd_read(rcan, CAN_INT);
+	if (isr & err_int) {
+		/* error interrupt */
+		if (rockchip_canfd_err(ndev, isr))
+			netdev_err(ndev, "can't allocate buffer - clearing pending interrupts\n");
+	}
+
+	rockchip_canfd_write(rcan, CAN_INT, isr);
+	return IRQ_HANDLED;
+}
+
+static int rockchip_canfd_open(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	int err;
+
+	/* common open */
+	err = open_candev(ndev);
+	if (err)
+		return err;
+
+	err = pm_runtime_get_sync(rcan->dev);
+	if (err < 0) {
+		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
+			   __func__, err);
+		goto exit;
+	}
+
+	err = rockchip_canfd_start(ndev);
+	if (err) {
+		netdev_err(ndev, "could not start CAN peripheral\n");
+		goto exit_can_start;
+	}
+
+	napi_enable(&rcan->napi);
+	netif_start_queue(ndev);
+
+	netdev_dbg(ndev, "%s\n", __func__);
+	return 0;
+
+exit_can_start:
+	pm_runtime_put(rcan->dev);
+exit:
+	close_candev(ndev);
+	return err;
+}
+
+static int rockchip_canfd_close(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);
+	napi_disable(&rcan->napi);
+	rockchip_canfd_stop(ndev);
+	close_candev(ndev);
+	pm_runtime_put(rcan->dev);
+
+	netdev_dbg(ndev, "%s\n", __func__);
+	return 0;
+}
+
+static const struct net_device_ops rockchip_canfd_netdev_ops = {
+	.ndo_open = rockchip_canfd_open,
+	.ndo_stop = rockchip_canfd_close,
+	.ndo_start_xmit = rockchip_canfd_start_xmit,
+	.ndo_change_mtu = can_change_mtu,
+};
+
+/**
+ * rockchip_canfd_suspend - Suspend method for the driver
+ * @dev:	Address of the device structure
+ *
+ * Put the driver into low power mode.
+ * Return: 0 on success and failure value on error
+ */
+static int __maybe_unused rockchip_canfd_suspend(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+
+	if (netif_running(ndev)) {
+		netif_stop_queue(ndev);
+		netif_device_detach(ndev);
+		rockchip_canfd_stop(ndev);
+	}
+
+	return pm_runtime_force_suspend(dev);
+}
+
+/**
+ * rockchip_canfd_resume - Resume from suspend
+ * @dev:	Address of the device structure
+ *
+ * Resume operation after suspend.
+ * Return: 0 on success and failure value on error
+ */
+static int __maybe_unused rockchip_canfd_resume(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret) {
+		dev_err(dev, "pm_runtime_force_resume failed on resume\n");
+		return ret;
+	}
+
+	if (netif_running(ndev)) {
+		ret = rockchip_canfd_start(ndev);
+		if (ret) {
+			dev_err(dev, "rockchip_canfd_chip_start failed on resume\n");
+			return ret;
+		}
+
+		netif_device_attach(ndev);
+		netif_start_queue(ndev);
+	}
+
+	return 0;
+}
+
+/**
+ * rockchip_canfd_runtime_suspend - Runtime suspend method for the driver
+ * @dev:	Address of the device structure
+ *
+ * Put the driver into low power mode.
+ * Return: 0 always
+ */
+static int __maybe_unused rockchip_canfd_runtime_suspend(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+
+	clk_bulk_disable_unprepare(rcan->num_clks, rcan->clks);
+
+	return 0;
+}
+
+/**
+ * rockchip_canfd_runtime_resume - Runtime resume from suspend
+ * @dev:	Address of the device structure
+ *
+ * Resume operation after suspend.
+ * Return: 0 on success and failure value on error
+ */
+static int __maybe_unused rockchip_canfd_runtime_resume(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	int ret;
+
+	ret = clk_bulk_prepare_enable(rcan->num_clks, rcan->clks);
+	if (ret) {
+		dev_err(dev, "Cannot enable clock.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops rockchip_canfd_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_canfd_suspend, rockchip_canfd_resume)
+	SET_RUNTIME_PM_OPS(rockchip_canfd_runtime_suspend,
+			   rockchip_canfd_runtime_resume, NULL)
+};
+
+static const struct of_device_id rockchip_canfd_of_match[] = {
+	{ .compatible = "rockchip,canfd-1.0" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rockchip_canfd_of_match);
+
+static int rockchip_canfd_probe(struct platform_device *pdev)
+{
+	struct net_device *ndev;
+	struct rockchip_canfd *rcan;
+	struct resource *res;
+	void __iomem *addr;
+	int err, irq;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "could not get a valid irq\n");
+		return -ENODEV;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	addr = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(addr))
+		return -EBUSY;
+
+	ndev = alloc_candev(sizeof(struct rockchip_canfd), 1);
+	if (!ndev) {
+		dev_err(&pdev->dev, "could not allocate memory for CANFD device\n");
+		return -ENOMEM;
+	}
+	rcan = netdev_priv(ndev);
+
+	/* register interrupt handler */
+	err = devm_request_irq(&pdev->dev, irq, rockchip_canfd_interrupt,
+			       0, ndev->name, ndev);
+	if (err) {
+		dev_err(&pdev->dev, "request_irq err: %d\n", err);
+		return err;
+	}
+
+	rcan->reset = devm_reset_control_array_get(&pdev->dev, false, false);
+	if (IS_ERR(rcan->reset)) {
+		if (PTR_ERR(rcan->reset) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "failed to get canfd reset lines\n");
+		return PTR_ERR(rcan->reset);
+	}
+	rcan->num_clks = devm_clk_bulk_get_all(&pdev->dev, &rcan->clks);
+	if (rcan->num_clks < 1)
+		return -ENODEV;
+
+	rcan->base = addr;
+	rcan->can.clock.freq = clk_get_rate(rcan->clks[0].clk);
+	rcan->dev = &pdev->dev;
+	rcan->can.state = CAN_STATE_STOPPED;
+	rcan->can.bittiming_const = &rockchip_canfd_bittiming_const;
+	rcan->can.data_bittiming_const = &rockchip_canfd_data_bittiming_const;
+	rcan->can.do_set_mode = rockchip_canfd_set_mode;
+	rcan->can.do_get_berr_counter = rockchip_canfd_get_berr_counter;
+	rcan->can.do_set_bittiming = rockchip_canfd_set_bittiming;
+	rcan->can.do_set_data_bittiming = rockchip_canfd_set_bittiming;
+	rcan->can.ctrlmode = CAN_CTRLMODE_FD;
+	/* IFI CANFD can do both Bosch FD and ISO FD */
+	rcan->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |
+				       CAN_CTRLMODE_FD;
+	rcan->can.restart_ms = 1;
+
+	ndev->netdev_ops = &rockchip_canfd_netdev_ops;
+	ndev->irq = irq;
+	ndev->flags |= IFF_ECHO;
+	spin_lock_init(&rcan->tx_lock);
+
+	platform_set_drvdata(pdev, ndev);
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	pm_runtime_enable(&pdev->dev);
+	err = pm_runtime_get_sync(&pdev->dev);
+	if (err < 0) {
+		dev_err(&pdev->dev, "%s: pm_runtime_get failed(%d)\n",
+			__func__, err);
+		goto err_pmdisable;
+	}
+	netif_napi_add(ndev, &rcan->napi, rockchip_canfd_rx_poll);
+	err = register_candev(ndev);
+	if (err) {
+		dev_err(&pdev->dev, "registering %s failed (err=%d)\n",
+			DRV_NAME, err);
+		goto err_disableclks;
+	}
+
+	return 0;
+
+err_disableclks:
+	pm_runtime_put(&pdev->dev);
+err_pmdisable:
+	pm_runtime_disable(&pdev->dev);
+	free_candev(ndev);
+
+	return err;
+}
+
+static int rockchip_canfd_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+
+	unregister_netdev(ndev);
+	pm_runtime_disable(&pdev->dev);
+	netif_napi_del(&rcan->napi);
+	free_candev(ndev);
+
+	return 0;
+}
+
+static struct platform_driver rockchip_canfd_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.pm = &rockchip_canfd_dev_pm_ops,
+		.of_match_table = rockchip_canfd_of_match,
+	},
+	.probe = rockchip_canfd_probe,
+	.remove = rockchip_canfd_remove,
+};
+module_platform_driver(rockchip_canfd_driver);
+
+MODULE_AUTHOR("Elaine Zhang <zhangqing@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip CANFD Drivers");
diff --git a/drivers/usb/typec/tcpm/fusb302.c b/drivers/usb/typec/tcpm/fusb302.c
index 7fc1ffa14f76..ec95221ac4a8 100644
--- a/drivers/usb/typec/tcpm/fusb302.c
+++ b/drivers/usb/typec/tcpm/fusb302.c
@@ -1748,7 +1748,7 @@ static int fusb302_probe(struct i2c_client *client)
 	}
 
 	ret = request_irq(chip->gpio_int_n_irq, fusb302_irq_intn,
-			  IRQF_ONESHOT | IRQF_TRIGGER_LOW,
+			  IRQF_TRIGGER_LOW,
 			  "fsc_interrupt_int_n", chip);
 	if (ret < 0) {
 		dev_err(dev, "cannot request IRQ for GPIO Int_N, ret=%d", ret);
diff --git a/drivers/usb/typec/tcpm/tcpm.c b/drivers/usb/typec/tcpm/tcpm.c
index cc1d83926497..4bb545822f99 100644
--- a/drivers/usb/typec/tcpm/tcpm.c
+++ b/drivers/usb/typec/tcpm/tcpm.c
@@ -5465,8 +5465,17 @@ static void tcpm_pd_event_handler(struct kthread_work *work)
 		if (events & TCPM_CC_EVENT) {
 			enum typec_cc_status cc1, cc2;
 
-			if (port->tcpc->get_cc(port->tcpc, &cc1, &cc2) == 0)
+			if (port->tcpc->get_cc(port->tcpc, &cc1, &cc2) == 0) {
 				_tcpm_cc_change(port, cc1, cc2);
+				if (tcpm_port_is_source(port)) {
+					enum typec_cc_polarity polarity =
+						port->cc2 == TYPEC_CC_RD ? TYPEC_POLARITY_CC2
+							 : TYPEC_POLARITY_CC1;
+					tcpm_set_polarity(port, polarity);
+					tcpm_set_roles(port, port->attached, TYPEC_SOURCE,
+						       tcpm_data_role_for_source(port));
+				}
+			}
 		}
 		if (events & TCPM_FRS_EVENT) {
 			if (port->state == SNK_READY) {

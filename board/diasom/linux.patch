diff --git a/arch/arm64/configs/imx8mm_diasom_evb_defconfig b/arch/arm64/configs/imx8mm_diasom_evb_defconfig
new file mode 100644
index 000000000000..88a9a762630f
--- /dev/null
+++ b/arch/arm64/configs/imx8mm_diasom_evb_defconfig
@@ -0,0 +1,554 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+# CONFIG_INITRAMFS_PRESERVE_MTIME is not set
+# CONFIG_SYSFS_SYSCALL is not set
+# CONFIG_FHANDLE is not set
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_ARCH_NXP=y
+CONFIG_ARCH_MXC=y
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_ARM64_ERRATUM_1742098 is not set
+# CONFIG_ARM64_ERRATUM_1024718 is not set
+# CONFIG_ARM64_ERRATUM_1418040 is not set
+# CONFIG_ARM64_ERRATUM_1165522 is not set
+# CONFIG_ARM64_ERRATUM_1319367 is not set
+# CONFIG_ARM64_ERRATUM_1530923 is not set
+# CONFIG_ARM64_ERRATUM_2441007 is not set
+# CONFIG_ARM64_ERRATUM_1286807 is not set
+# CONFIG_ARM64_ERRATUM_1463225 is not set
+# CONFIG_ARM64_ERRATUM_1542419 is not set
+# CONFIG_ARM64_ERRATUM_1508412 is not set
+# CONFIG_ARM64_ERRATUM_2051678 is not set
+# CONFIG_ARM64_ERRATUM_2077057 is not set
+# CONFIG_ARM64_ERRATUM_2658417 is not set
+# CONFIG_ARM64_ERRATUM_2054223 is not set
+# CONFIG_ARM64_ERRATUM_2067961 is not set
+# CONFIG_ARM64_ERRATUM_2441009 is not set
+# CONFIG_ARM64_ERRATUM_2457168 is not set
+# CONFIG_ARM64_ERRATUM_2645198 is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_CAVIUM_ERRATUM_30115 is not set
+# CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
+# CONFIG_FUJITSU_ERRATUM_010001 is not set
+# CONFIG_HISILICON_ERRATUM_161600802 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1003 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1009 is not set
+# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_E1041 is not set
+# CONFIG_NVIDIA_CARMEL_CNP_ERRATUM is not set
+# CONFIG_ROCKCHIP_ERRATUM_3588001 is not set
+# CONFIG_SOCIONEXT_SYNQUACER_PREITS is not set
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_HZ_1000=y
+# CONFIG_UNMAP_KERNEL_AT_EL0 is not set
+# CONFIG_MITIGATE_SPECTRE_BRANCH_HISTORY is not set
+# CONFIG_RODATA_FULL_DEFAULT_ENABLED is not set
+CONFIG_ARM64_SW_TTBR0_PAN=y
+CONFIG_COMPAT=y
+CONFIG_COMPAT_ALIGNMENT_FIXUPS=y
+CONFIG_ARM64_PMEM=y
+CONFIG_ARM64_PSEUDO_NMI=y
+# CONFIG_EFI is not set
+CONFIG_ENERGY_MODEL=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_CPU_IDLE_GOV_TEO=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_IMX_CPUFREQ_DT=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_VMAP_STACK is not set
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEBUG_FS is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_CMDLINE_PARTITION=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_COREDUMP is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+# CONFIG_ZONE_DMA is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_SECRETMEM is not set
+CONFIG_USERFAULTFD=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_INET_RAW_DIAG=y
+CONFIG_INET_DIAG_DESTROY=y
+# CONFIG_IPV6 is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEASPM_POWERSAVE=y
+# CONFIG_VGA_ARB is not set
+CONFIG_PCI_IMX6_HOST=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_ARM_SMCCC_SOC_ID is not set
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTD_NAND_GPMI_NAND=y
+# CONFIG_MTD_NAND_ECC_SW_HAMMING is not set
+CONFIG_BLK_DEV_NVME=y
+CONFIG_SRAM=y
+CONFIG_EEPROM_AT24=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+# CONFIG_ATA_FORCE is not set
+# CONFIG_SATA_PMP is not set
+CONFIG_AHCI_IMX=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ASIX is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CADENCE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_NET_VENDOR_DAVICOM is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_ENGLEDER is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+CONFIG_FEC=y
+# CONFIG_NET_VENDOR_FUNGIBLE is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_ADI is not set
+# CONFIG_NET_VENDOR_LITEX is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+# CONFIG_NET_VENDOR_MICROSOFT is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETERION is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_NET_VENDOR_PACKET_ENGINES is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VERTEXCOM is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WANGXUN is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_NET_VENDOR_XILINX is not set
+CONFIG_DP83867_PHY=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_SNVS_PWRKEY=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_TIMERIOMEM=y
+# CONFIG_HW_RANDOM_CN10K is not set
+# CONFIG_DEVPORT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_GPIO=y
+CONFIG_I2C_GPIO_FAULT_INJECTOR=y
+CONFIG_I2C_IMX=y
+CONFIG_SPI=y
+CONFIG_SPI_NXP_FLEXSPI=y
+CONFIG_SPI_IMX=y
+CONFIG_SPI_SPIDEV=y
+# CONFIG_PTP_1588_CLOCK_KVM is not set
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_IMX8MM=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_MXC=y
+CONFIG_SYSCON_REBOOT_MODE=y
+# CONFIG_HWMON is not set
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR=y
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_IMX8MM_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_IMX2_WDT=y
+CONFIG_MFD_ROHM_BD718XX=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_BD718XX=y
+CONFIG_MEDIA_SUPPORT=y
+# CONFIG_DVB_NET is not set
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+# CONFIG_RADIO_ADAPTERS is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_IMX7_CSI=y
+CONFIG_VIDEO_IMX_MIPI_CSIS=y
+CONFIG_VIDEO_HANTRO=y
+CONFIG_VIDEO_AP1302=y
+CONFIG_VIDEO_OV5640=y
+# CONFIG_CXD2880_SPI_DRV is not set
+# CONFIG_MEDIA_TUNER_E4000 is not set
+# CONFIG_MEDIA_TUNER_FC0011 is not set
+# CONFIG_MEDIA_TUNER_FC0012 is not set
+# CONFIG_MEDIA_TUNER_FC0013 is not set
+# CONFIG_MEDIA_TUNER_FC2580 is not set
+# CONFIG_MEDIA_TUNER_IT913X is not set
+# CONFIG_MEDIA_TUNER_M88RS6000T is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MSI001 is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MXL301RF is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_QM1D1B0004 is not set
+# CONFIG_MEDIA_TUNER_QM1D1C0042 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_R820T is not set
+# CONFIG_MEDIA_TUNER_SI2157 is not set
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18250 is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_TUA9001 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_DVB_MXL5XX is not set
+# CONFIG_DVB_STB0899 is not set
+# CONFIG_DVB_STB6100 is not set
+# CONFIG_DVB_STV090x is not set
+# CONFIG_DVB_STV0910 is not set
+# CONFIG_DVB_STV6110x is not set
+# CONFIG_DVB_STV6111 is not set
+# CONFIG_DVB_DRXK is not set
+# CONFIG_DVB_MN88472 is not set
+# CONFIG_DVB_MN88473 is not set
+# CONFIG_DVB_SI2165 is not set
+# CONFIG_DVB_TDA18271C2DD is not set
+# CONFIG_DVB_CX24110 is not set
+# CONFIG_DVB_CX24116 is not set
+# CONFIG_DVB_CX24117 is not set
+# CONFIG_DVB_CX24120 is not set
+# CONFIG_DVB_CX24123 is not set
+# CONFIG_DVB_DS3000 is not set
+# CONFIG_DVB_MB86A16 is not set
+# CONFIG_DVB_MT312 is not set
+# CONFIG_DVB_S5H1420 is not set
+# CONFIG_DVB_SI21XX is not set
+# CONFIG_DVB_STB6000 is not set
+# CONFIG_DVB_STV0288 is not set
+# CONFIG_DVB_STV0299 is not set
+# CONFIG_DVB_STV0900 is not set
+# CONFIG_DVB_STV6110 is not set
+# CONFIG_DVB_TDA10071 is not set
+# CONFIG_DVB_TDA10086 is not set
+# CONFIG_DVB_TDA8083 is not set
+# CONFIG_DVB_TDA8261 is not set
+# CONFIG_DVB_TDA826X is not set
+# CONFIG_DVB_TS2020 is not set
+# CONFIG_DVB_TUA6100 is not set
+# CONFIG_DVB_TUNER_CX24113 is not set
+# CONFIG_DVB_TUNER_ITD1000 is not set
+# CONFIG_DVB_VES1X93 is not set
+# CONFIG_DVB_ZL10036 is not set
+# CONFIG_DVB_ZL10039 is not set
+# CONFIG_DVB_CX22700 is not set
+# CONFIG_DVB_CX22702 is not set
+# CONFIG_DVB_CXD2820R is not set
+# CONFIG_DVB_CXD2841ER is not set
+# CONFIG_DVB_DIB3000MB is not set
+# CONFIG_DVB_DIB3000MC is not set
+# CONFIG_DVB_DIB7000M is not set
+# CONFIG_DVB_DIB7000P is not set
+# CONFIG_DVB_DIB9000 is not set
+# CONFIG_DVB_DRXD is not set
+# CONFIG_DVB_EC100 is not set
+# CONFIG_DVB_L64781 is not set
+# CONFIG_DVB_MT352 is not set
+# CONFIG_DVB_NXT6000 is not set
+# CONFIG_DVB_S5H1432 is not set
+# CONFIG_DVB_SP887X is not set
+# CONFIG_DVB_STV0367 is not set
+# CONFIG_DVB_TDA10048 is not set
+# CONFIG_DVB_TDA1004X is not set
+# CONFIG_DVB_ZD1301_DEMOD is not set
+# CONFIG_DVB_ZL10353 is not set
+# CONFIG_DVB_CXD2880 is not set
+# CONFIG_DVB_STV0297 is not set
+# CONFIG_DVB_TDA10021 is not set
+# CONFIG_DVB_TDA10023 is not set
+# CONFIG_DVB_VES1820 is not set
+# CONFIG_DVB_AU8522_DTV is not set
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_BCM3510 is not set
+# CONFIG_DVB_LG2160 is not set
+# CONFIG_DVB_LGDT3305 is not set
+# CONFIG_DVB_LGDT330X is not set
+# CONFIG_DVB_MXL692 is not set
+# CONFIG_DVB_NXT200X is not set
+# CONFIG_DVB_OR51132 is not set
+# CONFIG_DVB_OR51211 is not set
+# CONFIG_DVB_S5H1409 is not set
+# CONFIG_DVB_S5H1411 is not set
+# CONFIG_DVB_DIB8000 is not set
+# CONFIG_DVB_MB86A20S is not set
+# CONFIG_DVB_S921 is not set
+# CONFIG_DVB_MN88443X is not set
+# CONFIG_DVB_TC90522 is not set
+# CONFIG_DVB_PLL is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+# CONFIG_DVB_A8293 is not set
+# CONFIG_DVB_AF9033 is not set
+# CONFIG_DVB_ASCOT2E is not set
+# CONFIG_DVB_ATBM8830 is not set
+# CONFIG_DVB_HELENE is not set
+# CONFIG_DVB_HORUS3A is not set
+# CONFIG_DVB_ISL6405 is not set
+# CONFIG_DVB_ISL6421 is not set
+# CONFIG_DVB_ISL6423 is not set
+# CONFIG_DVB_IX2505V is not set
+# CONFIG_DVB_LGS8GL5 is not set
+# CONFIG_DVB_LGS8GXX is not set
+# CONFIG_DVB_LNBH25 is not set
+# CONFIG_DVB_LNBH29 is not set
+# CONFIG_DVB_LNBP21 is not set
+# CONFIG_DVB_LNBP22 is not set
+# CONFIG_DVB_M88RS2000 is not set
+# CONFIG_DVB_TDA665x is not set
+# CONFIG_DVB_DRX39XYJ is not set
+# CONFIG_DVB_CXD2099 is not set
+# CONFIG_DVB_SP2 is not set
+CONFIG_DRM=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+CONFIG_DRM_DISPLAY_CONNECTOR=y
+CONFIG_DRM_SAMSUNG_DSIM=y
+CONFIG_DRM_I2C_ADV7511=y
+CONFIG_DRM_ETNAVIV=y
+CONFIG_DRM_MXSFB=y
+CONFIG_FB=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_DYNAMIC_MINORS=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_PCI is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_AUDIO_MIDI_V2=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_FSL_SAI=y
+CONFIG_SND_SOC_FSL_MICFIL=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+CONFIG_SND_SOC_BT_SCO=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=m
+CONFIG_HID_GENERIC=m
+CONFIG_USB_HID=m
+CONFIG_USB_HIDDEV=y
+CONFIG_USB_KBD=m
+CONFIG_USB_MOUSE=m
+# CONFIG_I2C_HID is not set
+CONFIG_USB_CONN_GPIO=y
+CONFIG_USB=y
+# CONFIG_USB_PCI is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_FEW_INIT_RETRIES=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_FSL=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_HOST=y
+# CONFIG_USB_CHIPIDEA_MSM is not set
+# CONFIG_USB_CHIPIDEA_GENERIC is not set
+# CONFIG_USB_CHIPIDEA_TEGRA is not set
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_ACTIVITY=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_SNVS=y
+CONFIG_DMADEVICES=y
+CONFIG_IMX_SDMA=y
+CONFIG_MXS_DMA=y
+# CONFIG_MX3_IPU is not set
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+CONFIG_DMABUF_HEAPS_CMA=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+CONFIG_CLK_IMX8MM=y
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_ARM64_ERRATUM_858921 is not set
+CONFIG_IMX_MBOX=y
+CONFIG_IOMMU_IO_PGTABLE_LPAE=y
+CONFIG_REMOTEPROC=y
+CONFIG_IMX_REMOTEPROC=y
+# CONFIG_SOC_IMX9 is not set
+CONFIG_PWM=y
+CONFIG_PWM_IMX27=y
+# CONFIG_IMX_IRQSTEER is not set
+# CONFIG_IMX_MU_MSI is not set
+CONFIG_RESET_IMX7=y
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+CONFIG_PHY_FSL_IMX8M_PCIE=y
+CONFIG_FSL_IMX8_DDR_PMU=y
+CONFIG_NVMEM_IMX_OCOTP=y
+CONFIG_NVMEM_SNVS_LPGPR=y
+CONFIG_INTERCONNECT=y
+CONFIG_INTERCONNECT_IMX=y
+CONFIG_INTERCONNECT_IMX8MM=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_F2FS_FS=y
+# CONFIG_F2FS_STAT_FS is not set
+# CONFIG_F2FS_FS_XATTR is not set
+# CONFIG_F2FS_IOSTAT is not set
+CONFIG_FSCACHE=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=866
+CONFIG_FAT_DEFAULT_IOCHARSET="cp1251"
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_EXFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+# CONFIG_PROC_PAGE_MONITOR is not set
+CONFIG_CONFIGFS_FS=y
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_UTF8=y
+CONFIG_LSM="landlock,lockdown,yama,loadpin,safesetid,selinux,smack,tomoyo,apparmor,bpf"
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CMA_SIZE_MBYTES=64
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_PANIC_TIMEOUT=5
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_FTRACE is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff --git a/arch/arm64/configs/rk3568_mg_evb_defconfig b/arch/arm64/configs/rk3568_mg_evb_defconfig
new file mode 100644
index 000000000000..24f0d92c797b
--- /dev/null
+++ b/arch/arm64/configs/rk3568_mg_evb_defconfig
@@ -0,0 +1,573 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+# CONFIG_INITRAMFS_PRESERVE_MTIME is not set
+# CONFIG_SYSFS_SYSCALL is not set
+# CONFIG_FHANDLE is not set
+CONFIG_EMBEDDED=y
+CONFIG_ARCH_ROCKCHIP=y
+# CONFIG_AMPERE_ERRATUM_AC03_CPU_38 is not set
+# CONFIG_ARM64_ERRATUM_826319 is not set
+# CONFIG_ARM64_ERRATUM_827319 is not set
+# CONFIG_ARM64_ERRATUM_824069 is not set
+# CONFIG_ARM64_ERRATUM_819472 is not set
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_ARM64_ERRATUM_1742098 is not set
+# CONFIG_ARM64_ERRATUM_845719 is not set
+# CONFIG_ARM64_ERRATUM_843419 is not set
+# CONFIG_ARM64_ERRATUM_1418040 is not set
+# CONFIG_ARM64_ERRATUM_1165522 is not set
+# CONFIG_ARM64_ERRATUM_1319367 is not set
+# CONFIG_ARM64_ERRATUM_1286807 is not set
+# CONFIG_ARM64_ERRATUM_1463225 is not set
+# CONFIG_ARM64_ERRATUM_1542419 is not set
+# CONFIG_ARM64_ERRATUM_1508412 is not set
+# CONFIG_ARM64_ERRATUM_2051678 is not set
+# CONFIG_ARM64_ERRATUM_2077057 is not set
+# CONFIG_ARM64_ERRATUM_2658417 is not set
+# CONFIG_ARM64_ERRATUM_2054223 is not set
+# CONFIG_ARM64_ERRATUM_2067961 is not set
+# CONFIG_ARM64_ERRATUM_2441009 is not set
+# CONFIG_ARM64_ERRATUM_2457168 is not set
+# CONFIG_ARM64_ERRATUM_2645198 is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_CAVIUM_ERRATUM_30115 is not set
+# CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
+# CONFIG_FUJITSU_ERRATUM_010001 is not set
+# CONFIG_HISILICON_ERRATUM_161600802 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1003 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1009 is not set
+# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_E1041 is not set
+# CONFIG_NVIDIA_CARMEL_CNP_ERRATUM is not set
+# CONFIG_SOCIONEXT_SYNQUACER_PREITS is not set
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_HZ_1000=y
+# CONFIG_UNMAP_KERNEL_AT_EL0 is not set
+# CONFIG_MITIGATE_SPECTRE_BRANCH_HISTORY is not set
+# CONFIG_RODATA_FULL_DEFAULT_ENABLED is not set
+CONFIG_ARM64_SW_TTBR0_PAN=y
+CONFIG_COMPAT=y
+CONFIG_COMPAT_ALIGNMENT_FIXUPS=y
+CONFIG_ARM64_PSEUDO_NMI=y
+# CONFIG_EFI is not set
+CONFIG_ENERGY_MODEL=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_CPU_IDLE_GOV_TEO=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_SCMI_CPUFREQ=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_VMAP_STACK is not set
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEBUG_FS is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_CMDLINE_PARTITION=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_COREDUMP is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_CMA=y
+# CONFIG_ZONE_DMA is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_SECRETMEM is not set
+CONFIG_USERFAULTFD=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_INET_RAW_DIAG=y
+CONFIG_INET_DIAG_DESTROY=y
+# CONFIG_IPV6 is not set
+CONFIG_NETLINK_DIAG=y
+CONFIG_CAN=y
+# CONFIG_CAN_BCM is not set
+# CONFIG_CAN_GW is not set
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEASPM_POWERSAVE=y
+# CONFIG_VGA_ARB is not set
+CONFIG_PCIE_ROCKCHIP_DW_HOST=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_ARM_SCMI_PROTOCOL=y
+# CONFIG_ARM_SCMI_POWER_DOMAIN is not set
+# CONFIG_ARM_SMCCC_SOC_ID is not set
+CONFIG_BLK_DEV_NVME=y
+CONFIG_SRAM=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+# CONFIG_ATA_FORCE is not set
+# CONFIG_SATA_PMP is not set
+CONFIG_AHCI_DWC=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ASIX is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CADENCE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_NET_VENDOR_DAVICOM is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_ENGLEDER is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_FUNGIBLE is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_ADI is not set
+# CONFIG_NET_VENDOR_LITEX is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+# CONFIG_NET_VENDOR_MICROSOFT is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETERION is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_NET_VENDOR_PACKET_ENGINES is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+CONFIG_STMMAC_ETH=y
+# CONFIG_DWMAC_GENERIC is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VERTEXCOM is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WANGXUN is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_NET_VENDOR_XILINX is not set
+CONFIG_REALTEK_PHY=y
+CONFIG_ROCKCHIP_PHY=y
+CONFIG_CANFD_ROCKCHIP=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_RK805_PWRKEY=y
+# CONFIG_SERIO is not set
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_NR_UARTS=10
+CONFIG_SERIAL_8250_RUNTIME_UARTS=10
+CONFIG_SERIAL_8250_DW=y
+# CONFIG_SERIAL_8250_PERICOM is not set
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_TIMERIOMEM=y
+# CONFIG_HW_RANDOM_CN10K is not set
+# CONFIG_DEVPORT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_RK3X=y
+CONFIG_SPI=y
+CONFIG_SPI_ROCKCHIP=y
+CONFIG_SPI_SPIDEV=y
+# CONFIG_PTP_1588_CLOCK_KVM is not set
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_SYSCON_REBOOT_MODE=y
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR=y
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_ROCKCHIP_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_MFD_RK8XX_I2C=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_RK808=y
+CONFIG_MEDIA_SUPPORT=y
+# CONFIG_DVB_NET is not set
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+# CONFIG_RADIO_ADAPTERS is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_ROCKCHIP_RGA=y
+CONFIG_VIDEO_HANTRO=y
+# CONFIG_CXD2880_SPI_DRV is not set
+# CONFIG_MEDIA_TUNER_E4000 is not set
+# CONFIG_MEDIA_TUNER_FC0011 is not set
+# CONFIG_MEDIA_TUNER_FC0012 is not set
+# CONFIG_MEDIA_TUNER_FC0013 is not set
+# CONFIG_MEDIA_TUNER_FC2580 is not set
+# CONFIG_MEDIA_TUNER_IT913X is not set
+# CONFIG_MEDIA_TUNER_M88RS6000T is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MSI001 is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MXL301RF is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_QM1D1B0004 is not set
+# CONFIG_MEDIA_TUNER_QM1D1C0042 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_R820T is not set
+# CONFIG_MEDIA_TUNER_SI2157 is not set
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18250 is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_TUA9001 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_DVB_MXL5XX is not set
+# CONFIG_DVB_STB0899 is not set
+# CONFIG_DVB_STB6100 is not set
+# CONFIG_DVB_STV090x is not set
+# CONFIG_DVB_STV0910 is not set
+# CONFIG_DVB_STV6110x is not set
+# CONFIG_DVB_STV6111 is not set
+# CONFIG_DVB_DRXK is not set
+# CONFIG_DVB_MN88472 is not set
+# CONFIG_DVB_MN88473 is not set
+# CONFIG_DVB_SI2165 is not set
+# CONFIG_DVB_TDA18271C2DD is not set
+# CONFIG_DVB_CX24110 is not set
+# CONFIG_DVB_CX24116 is not set
+# CONFIG_DVB_CX24117 is not set
+# CONFIG_DVB_CX24120 is not set
+# CONFIG_DVB_CX24123 is not set
+# CONFIG_DVB_DS3000 is not set
+# CONFIG_DVB_MB86A16 is not set
+# CONFIG_DVB_MT312 is not set
+# CONFIG_DVB_S5H1420 is not set
+# CONFIG_DVB_SI21XX is not set
+# CONFIG_DVB_STB6000 is not set
+# CONFIG_DVB_STV0288 is not set
+# CONFIG_DVB_STV0299 is not set
+# CONFIG_DVB_STV0900 is not set
+# CONFIG_DVB_STV6110 is not set
+# CONFIG_DVB_TDA10071 is not set
+# CONFIG_DVB_TDA10086 is not set
+# CONFIG_DVB_TDA8083 is not set
+# CONFIG_DVB_TDA8261 is not set
+# CONFIG_DVB_TDA826X is not set
+# CONFIG_DVB_TS2020 is not set
+# CONFIG_DVB_TUA6100 is not set
+# CONFIG_DVB_TUNER_CX24113 is not set
+# CONFIG_DVB_TUNER_ITD1000 is not set
+# CONFIG_DVB_VES1X93 is not set
+# CONFIG_DVB_ZL10036 is not set
+# CONFIG_DVB_ZL10039 is not set
+# CONFIG_DVB_CX22700 is not set
+# CONFIG_DVB_CX22702 is not set
+# CONFIG_DVB_CXD2820R is not set
+# CONFIG_DVB_CXD2841ER is not set
+# CONFIG_DVB_DIB3000MB is not set
+# CONFIG_DVB_DIB3000MC is not set
+# CONFIG_DVB_DIB7000M is not set
+# CONFIG_DVB_DIB7000P is not set
+# CONFIG_DVB_DIB9000 is not set
+# CONFIG_DVB_DRXD is not set
+# CONFIG_DVB_EC100 is not set
+# CONFIG_DVB_L64781 is not set
+# CONFIG_DVB_MT352 is not set
+# CONFIG_DVB_NXT6000 is not set
+# CONFIG_DVB_S5H1432 is not set
+# CONFIG_DVB_SP887X is not set
+# CONFIG_DVB_STV0367 is not set
+# CONFIG_DVB_TDA10048 is not set
+# CONFIG_DVB_TDA1004X is not set
+# CONFIG_DVB_ZD1301_DEMOD is not set
+# CONFIG_DVB_ZL10353 is not set
+# CONFIG_DVB_CXD2880 is not set
+# CONFIG_DVB_STV0297 is not set
+# CONFIG_DVB_TDA10021 is not set
+# CONFIG_DVB_TDA10023 is not set
+# CONFIG_DVB_VES1820 is not set
+# CONFIG_DVB_AU8522_DTV is not set
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_BCM3510 is not set
+# CONFIG_DVB_LG2160 is not set
+# CONFIG_DVB_LGDT3305 is not set
+# CONFIG_DVB_LGDT330X is not set
+# CONFIG_DVB_MXL692 is not set
+# CONFIG_DVB_NXT200X is not set
+# CONFIG_DVB_OR51132 is not set
+# CONFIG_DVB_OR51211 is not set
+# CONFIG_DVB_S5H1409 is not set
+# CONFIG_DVB_S5H1411 is not set
+# CONFIG_DVB_DIB8000 is not set
+# CONFIG_DVB_MB86A20S is not set
+# CONFIG_DVB_S921 is not set
+# CONFIG_DVB_MN88443X is not set
+# CONFIG_DVB_TC90522 is not set
+# CONFIG_DVB_PLL is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+# CONFIG_DVB_A8293 is not set
+# CONFIG_DVB_AF9033 is not set
+# CONFIG_DVB_ASCOT2E is not set
+# CONFIG_DVB_ATBM8830 is not set
+# CONFIG_DVB_HELENE is not set
+# CONFIG_DVB_HORUS3A is not set
+# CONFIG_DVB_ISL6405 is not set
+# CONFIG_DVB_ISL6421 is not set
+# CONFIG_DVB_ISL6423 is not set
+# CONFIG_DVB_IX2505V is not set
+# CONFIG_DVB_LGS8GL5 is not set
+# CONFIG_DVB_LGS8GXX is not set
+# CONFIG_DVB_LNBH25 is not set
+# CONFIG_DVB_LNBH29 is not set
+# CONFIG_DVB_LNBP21 is not set
+# CONFIG_DVB_LNBP22 is not set
+# CONFIG_DVB_M88RS2000 is not set
+# CONFIG_DVB_TDA665x is not set
+# CONFIG_DVB_DRX39XYJ is not set
+# CONFIG_DVB_CXD2099 is not set
+# CONFIG_DVB_SP2 is not set
+CONFIG_DRM=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+CONFIG_DRM_ROCKCHIP=y
+# CONFIG_ROCKCHIP_VOP is not set
+CONFIG_ROCKCHIP_VOP2=y
+CONFIG_ROCKCHIP_DW_HDMI=y
+CONFIG_ROCKCHIP_DW_MIPI_DSI=y
+CONFIG_DRM_PANEL_SIMPLE=y
+CONFIG_DRM_DISPLAY_CONNECTOR=y
+CONFIG_DRM_DW_HDMI_I2S_AUDIO=y
+CONFIG_DRM_DW_HDMI_CEC=y
+CONFIG_DRM_PANFROST=y
+CONFIG_FB=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_DYNAMIC_MINORS=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_PCI is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_AUDIO_MIDI_V2=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_ROCKCHIP=y
+CONFIG_SND_SOC_ROCKCHIP_I2S_TDM=y
+CONFIG_SND_SOC_ROCKCHIP_PDM=y
+CONFIG_SND_SOC_ROCKCHIP_SPDIF=y
+CONFIG_SND_SOC_BT_SCO=y
+CONFIG_SND_SOC_ES8328_I2C=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=m
+CONFIG_HID_GENERIC=m
+CONFIG_USB_HID=m
+CONFIG_USB_HIDDEV=y
+CONFIG_USB_KBD=m
+CONFIG_USB_MOUSE=m
+# CONFIG_I2C_HID is not set
+CONFIG_USB=y
+# CONFIG_USB_PCI is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_FEW_INIT_RETRIES=y
+CONFIG_USB_OTG=y
+CONFIG_USB_OTG_FSM=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_ONBOARD_HUB=y
+CONFIG_TYPEC=y
+CONFIG_TYPEC_TCPM=y
+CONFIG_TYPEC_TCPCI=y
+CONFIG_TYPEC_FUSB302=y
+CONFIG_TYPEC_MUX_GPIO_SBU=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_DWCMSHC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_ROCKCHIP=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_ACTIVITY=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_RK808=y
+CONFIG_DMADEVICES=y
+CONFIG_PL330_DMA=y
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+CONFIG_DMABUF_HEAPS_CMA=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_SURFACE_PLATFORMS is not set
+CONFIG_COMMON_CLK_SCMI=y
+# CONFIG_CLK_PX30 is not set
+# CONFIG_CLK_RK3308 is not set
+# CONFIG_CLK_RK3328 is not set
+# CONFIG_CLK_RK3368 is not set
+# CONFIG_CLK_RK3399 is not set
+# CONFIG_CLK_RK3588 is not set
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+CONFIG_MAILBOX=y
+CONFIG_ROCKCHIP_MBOX=y
+CONFIG_ROCKCHIP_IOMMU=y
+CONFIG_ARM_SMMU_V3=y
+CONFIG_ROCKCHIP_IODOMAIN=y
+CONFIG_ROCKCHIP_PM_DOMAINS=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER_CB=y
+CONFIG_ROCKCHIP_SARADC=y
+CONFIG_PWM=y
+CONFIG_PWM_ROCKCHIP=y
+CONFIG_PHY_ROCKCHIP_INNO_HDMI=y
+CONFIG_PHY_ROCKCHIP_INNO_USB2=y
+CONFIG_PHY_ROCKCHIP_INNO_CSIDPHY=y
+CONFIG_PHY_ROCKCHIP_INNO_DSIDPHY=y
+CONFIG_PHY_ROCKCHIP_NANENG_COMBO_PHY=y
+CONFIG_PHY_ROCKCHIP_SNPS_PCIE3=y
+CONFIG_PHY_ROCKCHIP_TYPEC=y
+CONFIG_PHY_ROCKCHIP_USB=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_F2FS_FS=y
+# CONFIG_F2FS_STAT_FS is not set
+# CONFIG_F2FS_FS_XATTR is not set
+# CONFIG_F2FS_IOSTAT is not set
+CONFIG_FSCACHE=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=866
+CONFIG_FAT_DEFAULT_IOCHARSET="cp1251"
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_EXFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+# CONFIG_PROC_PAGE_MONITOR is not set
+CONFIG_TMPFS=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_UTF8=y
+CONFIG_LSM="landlock,lockdown,yama,loadpin,safesetid,selinux,smack,tomoyo,apparmor,bpf"
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_HW is not set
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=64
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_PANIC_TIMEOUT=5
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_FTRACE is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
index 2254457ab5d0..9aeeb63435cd 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
@@ -786,8 +786,13 @@ static void adv7511_mode_set(struct adv7511 *adv7511,
 	else
 		low_refresh_rate = ADV7511_LOW_REFRESH_RATE_NONE;
 
-	regmap_update_bits(adv7511->regmap, 0xfb,
-		0x6, low_refresh_rate << 1);
+	if (adv7511->type == ADV7511)
+		regmap_update_bits(adv7511->regmap, 0xfb,
+				   0x6, low_refresh_rate << 1);
+	else
+		regmap_update_bits(adv7511->regmap, 0x4a,
+				   0xc, low_refresh_rate << 2);
+
 	regmap_update_bits(adv7511->regmap, 0x17,
 		0x60, (vsync_polarity << 6) | (hsync_polarity << 5));
 
diff --git a/drivers/gpu/drm/bridge/samsung-dsim.c b/drivers/gpu/drm/bridge/samsung-dsim.c
index 73ec60757dbc..9e253af69c7a 100644
--- a/drivers/gpu/drm/bridge/samsung-dsim.c
+++ b/drivers/gpu/drm/bridge/samsung-dsim.c
@@ -1009,7 +1009,7 @@ static int samsung_dsim_wait_for_hdr_fifo(struct samsung_dsim *dsi)
 	do {
 		u32 reg = samsung_dsim_read(dsi, DSIM_FIFOCTRL_REG);
 
-		if (!(reg & DSIM_SFR_HEADER_FULL))
+		if (reg & DSIM_SFR_HEADER_EMPTY)
 			return 0;
 
 		if (!cond_resched())
diff --git a/drivers/gpu/drm/mxsfb/mxsfb_kms.c b/drivers/gpu/drm/mxsfb/mxsfb_kms.c
index 3bcc9c0f2019..608d850e4154 100644
--- a/drivers/gpu/drm/mxsfb/mxsfb_kms.c
+++ b/drivers/gpu/drm/mxsfb/mxsfb_kms.c
@@ -70,8 +70,9 @@ static void mxsfb_set_formats(struct mxsfb_drm_private *mxsfb,
 		ctrl |= CTRL_WORD_LENGTH_16;
 		ctrl1 |= CTRL1_SET_BYTE_PACKAGING(0xf);
 		break;
+	case DRM_FORMAT_ARGB8888:
 	case DRM_FORMAT_XRGB8888:
-		dev_dbg(drm->dev, "Setting up XRGB8888 mode\n");
+		dev_dbg(drm->dev, "Setting up xRGB8888 mode\n");
 		ctrl |= CTRL_WORD_LENGTH_24;
 		/* Do not use packed pixels = one pixel per word instead. */
 		ctrl1 |= CTRL1_SET_BYTE_PACKAGING(0x7);
@@ -641,6 +642,7 @@ static const struct drm_plane_funcs mxsfb_plane_funcs = {
 static const uint32_t mxsfb_primary_plane_formats[] = {
 	DRM_FORMAT_RGB565,
 	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ARGB8888,
 };
 
 static const uint32_t mxsfb_overlay_plane_formats[] = {
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 226454b6a90d..4096109a2c5a 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -34,6 +34,17 @@ config VIDEO_APTINA_PLL
 config VIDEO_CCS_PLL
 	tristate
 
+config VIDEO_AP1302
+	tristate "AP1302 external ISP support"
+	depends on I2C && VIDEO_DEV
+	select MEDIA_CONTROLLER
+	select REGMAP_I2C
+	select VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	help
+	  This is a Video4Linux2 sensor-level driver for the external
+	  ISP AP1302.
+
 config VIDEO_AR0521
 	tristate "ON Semiconductor AR0521 sensor support"
 	depends on I2C && VIDEO_DEV
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index c743aeb5d1ad..25b5852556e3 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_VIDEO_ADV7604) += adv7604.o
 obj-$(CONFIG_VIDEO_ADV7842) += adv7842.o
 obj-$(CONFIG_VIDEO_AK7375) += ak7375.o
 obj-$(CONFIG_VIDEO_AK881X) += ak881x.o
+obj-$(CONFIG_VIDEO_AP1302) += ap1302.o
 obj-$(CONFIG_VIDEO_APTINA_PLL) += aptina-pll.o
 obj-$(CONFIG_VIDEO_AR0521) += ar0521.o
 obj-$(CONFIG_VIDEO_BT819) += bt819.o
diff --git a/drivers/media/i2c/ap1302.c b/drivers/media/i2c/ap1302.c
new file mode 100644
index 000000000000..63b5a12519f5
--- /dev/null
+++ b/drivers/media/i2c/ap1302.c
@@ -0,0 +1,3921 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for the AP1302 external camera ISP from ON Semiconductor
+ *
+ * Copyright (C) 2021, Witekio, Inc.
+ * Copyright (C) 2021, Xilinx, Inc.
+ * Copyright (C) 2021, Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *
+ * Downloaded from https://github.com/Avnet/ap1302-driver
+ * at: 34bb3f3e2c771d07e96b1f52f7c2569af422da71
+ * Adopted to use with NVMEM, i.MX8MM CSI and kernel 6.5 by
+ * Alexander Shiyan <shc_work@mail.ru> (2023)
+ */
+
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/media.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define DRIVER_NAME "ap1302"
+
+#define AP1302_FW_WINDOW_SIZE			0x2000
+#define AP1302_FW_WINDOW_OFFSET			0x8000
+
+#define AP1302_MIN_WIDTH			24U
+#define AP1302_MIN_HEIGHT			16U
+#define AP1302_MAX_WIDTH			4224U
+#define AP1302_MAX_HEIGHT			4092U
+
+#define AP1302_REG_16BIT(n)			((2 << 24) | (n))
+#define AP1302_REG_32BIT(n)			((4 << 24) | (n))
+#define AP1302_REG_SIZE(n)			((n) >> 24)
+#define AP1302_REG_ADDR(n)			((n) & 0x0000ffff)
+#define AP1302_REG_PAGE(n)			((n) & 0x00ff0000)
+#define AP1302_REG_PAGE_MASK			0x00ff0000
+
+/* Info Registers */
+#define AP1302_CHIP_VERSION			AP1302_REG_16BIT(0x0000)
+#define AP1302_CHIP_ID				0x0265
+#define AP1302_FRAME_CNT			AP1302_REG_16BIT(0x0002)
+#define AP1302_ERROR				AP1302_REG_16BIT(0x0006)
+#define AP1302_ERR_FILE				AP1302_REG_32BIT(0x0008)
+#define AP1302_ERR_LINE				AP1302_REG_16BIT(0x000c)
+#define AP1302_SIPM_ERR_0			AP1302_REG_16BIT(0x0014)
+#define AP1302_SIPM_ERR_1			AP1302_REG_16BIT(0x0016)
+#define AP1302_CHIP_REV				AP1302_REG_16BIT(0x0050)
+#define AP1302_AF_POS				AP1302_REG_16BIT(0x01B0)
+#define AP1302_CON_BUF(n)			AP1302_REG_16BIT(0x0a2c + (n))
+#define AP1302_CON_BUF_SIZE			512
+
+/* Control Registers */
+#define AP1302_ORIENTATION			AP1302_REG_16BIT(0x100C)
+#define AP1302_ORIENTATION_HFLIP		(1U << 0)
+#define AP1302_ORIENTATION_VFLIP		(1U << 1)
+#define AP1302_DZ_TGT_FCT			AP1302_REG_16BIT(0x1010)
+#define AP1302_SFX_MODE				AP1302_REG_16BIT(0x1016)
+#define AP1302_SFX_MODE_SFX_MASK		0x00ff
+#define AP1302_SFX_MODE_SFX_NORMAL		(0U << 0)
+#define AP1302_SFX_MODE_SFX_ALIEN		(1U << 0)
+#define AP1302_SFX_MODE_SFX_ANTIQUE		(2U << 0)
+#define AP1302_SFX_MODE_SFX_BW			(3U << 0)
+#define AP1302_SFX_MODE_SFX_EMBOSS		(4U << 0)
+#define AP1302_SFX_MODE_SFX_EMBOSS_COLORED	(5U << 0)
+#define AP1302_SFX_MODE_SFX_GRAYSCALE		(6U << 0)
+#define AP1302_SFX_MODE_SFX_NEGATIVE		(7U << 0)
+#define AP1302_SFX_MODE_SFX_BLUISH		(8U << 0)
+#define AP1302_SFX_MODE_SFX_GREENISH		(9U << 0)
+#define AP1302_SFX_MODE_SFX_REDISH		(10U << 0)
+#define AP1302_SFX_MODE_SFX_POSTERIZE1		(11U << 0)
+#define AP1302_SFX_MODE_SFX_POSTERIZE2		(12U << 0)
+#define AP1302_SFX_MODE_SFX_SEPIA1		(13U << 0)
+#define AP1302_SFX_MODE_SFX_SEPIA2		(14U << 0)
+#define AP1302_SFX_MODE_SFX_SKETCH		(15U << 0)
+#define AP1302_SFX_MODE_SFX_SOLARIZE		(16U << 0)
+#define AP1302_SFX_MODE_SFX_FOGGY		(17U << 0)
+#define AP1302_BUBBLE_OUT_FMT			AP1302_REG_16BIT(0x1164)
+#define AP1302_BUBBLE_OUT_FMT_FT_YUV		(3U << 4)
+#define AP1302_BUBBLE_OUT_FMT_FT_RGB		(4U << 4)
+#define AP1302_BUBBLE_OUT_FMT_FT_YUV_JFIF	(5U << 4)
+#define AP1302_BUBBLE_OUT_FMT_FST_RGB_888	(0U << 0)
+#define AP1302_BUBBLE_OUT_FMT_FST_RGB_565	(1U << 0)
+#define AP1302_BUBBLE_OUT_FMT_FST_RGB_555M	(2U << 0)
+#define AP1302_BUBBLE_OUT_FMT_FST_RGB_555L	(3U << 0)
+#define AP1302_BUBBLE_OUT_FMT_FST_YUV_422	(0U << 0)
+#define AP1302_BUBBLE_OUT_FMT_FST_YUV_420	(1U << 0)
+#define AP1302_BUBBLE_OUT_FMT_FST_YUV_400	(2U << 0)
+#define AP1302_ATOMIC				AP1302_REG_16BIT(0x1184)
+#define AP1302_ATOMIC_MODE			BIT(2)
+#define AP1302_ATOMIC_FINISH			BIT(1)
+#define AP1302_ATOMIC_RECORD			BIT(0)
+
+/*
+ * Preview Context Registers (preview_*). AP1302 supports 3 "contexts"
+ * (Preview, Snapshot, Video). These can be programmed for different size,
+ * format, FPS, etc. There is no functional difference between the contexts,
+ * so the only potential benefit of using them is reduced number of register
+ * writes when switching output modes (if your concern is atomicity, see
+ * "atomic" register).
+ * So there's virtually no benefit in using contexts for this driver and it
+ * would significantly increase complexity. Let's use preview context only.
+ */
+#define AP1302_PREVIEW_WIDTH			AP1302_REG_16BIT(0x2000)
+#define AP1302_PREVIEW_HEIGHT			AP1302_REG_16BIT(0x2002)
+#define AP1302_PREVIEW_ROI_X0			AP1302_REG_16BIT(0x2004)
+#define AP1302_PREVIEW_ROI_Y0			AP1302_REG_16BIT(0x2006)
+#define AP1302_PREVIEW_ROI_X1			AP1302_REG_16BIT(0x2008)
+#define AP1302_PREVIEW_ROI_Y1			AP1302_REG_16BIT(0x200a)
+#define AP1302_PREVIEW_OUT_FMT			AP1302_REG_16BIT(0x2012)
+#define AP1302_PREVIEW_OUT_FMT_IPIPE_BYPASS	BIT(13)
+#define AP1302_PREVIEW_OUT_FMT_SS		BIT(12)
+#define AP1302_PREVIEW_OUT_FMT_FAKE_EN		BIT(11)
+#define AP1302_PREVIEW_OUT_FMT_ST_EN		BIT(10)
+#define AP1302_PREVIEW_OUT_FMT_IIS_NONE		(0U << 8)
+#define AP1302_PREVIEW_OUT_FMT_IIS_POST_VIEW	(1U << 8)
+#define AP1302_PREVIEW_OUT_FMT_IIS_VIDEO	(2U << 8)
+#define AP1302_PREVIEW_OUT_FMT_IIS_BUBBLE	(3U << 8)
+#define AP1302_PREVIEW_OUT_FMT_FT_JPEG_422	(0U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_JPEG_420	(1U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_YUV		(3U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_RGB		(4U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF	(5U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_RAW8		(8U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_RAW10		(9U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_RAW12		(10U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_RAW16		(11U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_DNG8		(12U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_DNG10		(13U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_DNG12		(14U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FT_DNG16		(15U << 4)
+#define AP1302_PREVIEW_OUT_FMT_FST_JPEG_ROTATE	BIT(2)
+#define AP1302_PREVIEW_OUT_FMT_FST_JPEG_SCAN	(0U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_JPEG_JFIF	(1U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_JPEG_EXIF	(2U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RGB_888	(0U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RGB_565	(1U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RGB_555M	(2U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RGB_555L	(3U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_YUV_422	(0U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_YUV_420	(1U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_YUV_400	(2U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RAW_SENSOR	(0U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RAW_CAPTURE	(1U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RAW_CP	(2U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RAW_BPC	(3U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RAW_IHDR	(4U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RAW_PP	(5U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RAW_DENSH	(6U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RAW_PM	(7U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RAW_GC	(8U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RAW_CURVE	(9U << 0)
+#define AP1302_PREVIEW_OUT_FMT_FST_RAW_CCONV	(10U << 0)
+#define AP1302_PREVIEW_S1_SENSOR_MODE		AP1302_REG_16BIT(0x202e)
+#define AP1302_PREVIEW_HINF_CTRL		AP1302_REG_16BIT(0x2030)
+#define AP1302_PREVIEW_HINF_CTRL_BT656_LE	BIT(15)
+#define AP1302_PREVIEW_HINF_CTRL_BT656_16BIT	BIT(14)
+#define AP1302_PREVIEW_HINF_CTRL_MUX_DELAY(n)	((n) << 8)
+#define AP1302_PREVIEW_HINF_CTRL_LV_POL		BIT(7)
+#define AP1302_PREVIEW_HINF_CTRL_FV_POL		BIT(6)
+#define AP1302_PREVIEW_HINF_CTRL_MIPI_CONT_CLK	BIT(5)
+#define AP1302_PREVIEW_HINF_CTRL_SPOOF		BIT(4)
+#define AP1302_PREVIEW_HINF_CTRL_MIPI_MODE	BIT(3)
+#define AP1302_PREVIEW_HINF_CTRL_MIPI_LANES(n)	((n) << 0)
+
+/* IQ Registers */
+#define AP1302_AE_CTRL				AP1302_REG_16BIT(0x5002)
+#define AP1302_AE_CTRL_STATS_SEL		BIT(11)
+#define AP1302_AE_CTRL_IMM			BIT(10)
+#define AP1302_AE_CTRL_ROUND_ISO		BIT(9)
+#define AP1302_AE_CTRL_UROI_FACE		BIT(7)
+#define AP1302_AE_CTRL_UROI_LOCK		BIT(6)
+#define AP1302_AE_CTRL_UROI_BOUND		BIT(5)
+#define AP1302_AE_CTRL_IMM1			BIT(4)
+#define AP1302_AE_CTRL_MANUAL_EXP_TIME_GAIN	(0U << 0)
+#define AP1302_AE_CTRL_MANUAL_BV_EXP_TIME	(1U << 0)
+#define AP1302_AE_CTRL_MANUAL_BV_GAIN		(2U << 0)
+#define AP1302_AE_CTRL_MANUAL_BV_ISO		(3U << 0)
+#define AP1302_AE_CTRL_AUTO_BV_EXP_TIME		(9U << 0)
+#define AP1302_AE_CTRL_AUTO_BV_GAIN		(10U << 0)
+#define AP1302_AE_CTRL_AUTO_BV_ISO		(11U << 0)
+#define AP1302_AE_CTRL_FULL_AUTO		(12U << 0)
+#define AP1302_AE_CTRL_MODE_MASK		0x000f
+#define AP1302_AE_MANUAL_GAIN			AP1302_REG_16BIT(0x5006)
+#define AP1302_AE_MANUAL_GAIN_MASK		0xFFFF
+#define AP1302_AE_BV_OFF			AP1302_REG_16BIT(0x5014)
+#define AP1302_AE_MET				AP1302_REG_16BIT(0x503E)
+#define AP1302_AE_MET_MASK			0x0003
+#define AP1302_AF_CTRL				AP1302_REG_16BIT(0x5058)
+#define AP1302_AF_CTRL_MODE_MASK		0x0003
+#define AP1302_AF_CTRL_MODE_OFF			(0U << 0)
+#define AP1302_AF_CTRL_MODE_STANDBY		(1U << 0)
+#define AP1302_AF_CTRL_MODE_AUTO		(2U << 0)
+#define AP1302_AF_CTRL_MODE_MANUAL		(3U << 0)
+#define AP1302_AF_CTRL_TRIGGER			BIT(3)
+#define AP1302_AWB_CTRL				AP1302_REG_16BIT(0x5100)
+#define AP1302_AWB_CTRL_RECALC			BIT(13)
+#define AP1302_AWB_CTRL_POSTGAIN		BIT(12)
+#define AP1302_AWB_CTRL_UNGAIN			BIT(11)
+#define AP1302_AWB_CTRL_CLIP			BIT(10)
+#define AP1302_AWB_CTRL_SKY			BIT(9)
+#define AP1302_AWB_CTRL_FLASH			BIT(8)
+#define AP1302_AWB_CTRL_FACE_OFF		(0U << 6)
+#define AP1302_AWB_CTRL_FACE_IGNORE		(1U << 6)
+#define AP1302_AWB_CTRL_FACE_CONSTRAINED	(2U << 6)
+#define AP1302_AWB_CTRL_FACE_ONLY		(3U << 6)
+#define AP1302_AWB_CTRL_IMM			BIT(5)
+#define AP1302_AWB_CTRL_IMM1			BIT(4)
+#define AP1302_AWB_CTRL_MODE_OFF		(0U << 0)
+#define AP1302_AWB_CTRL_MODE_HORIZON		(1U << 0)
+#define AP1302_AWB_CTRL_MODE_A			(2U << 0)
+#define AP1302_AWB_CTRL_MODE_CWF		(3U << 0)
+#define AP1302_AWB_CTRL_MODE_D50		(4U << 0)
+#define AP1302_AWB_CTRL_MODE_D65		(5U << 0)
+#define AP1302_AWB_CTRL_MODE_D75		(6U << 0)
+#define AP1302_AWB_CTRL_MODE_MANUAL		(7U << 0)
+#define AP1302_AWB_CTRL_MODE_MEASURE		(8U << 0)
+#define AP1302_AWB_CTRL_MODE_AUTO		(15U << 0)
+#define AP1302_AWB_CTRL_MODE_MASK		0x000f
+#define AP1302_FLICK_CTRL			AP1302_REG_16BIT(0x5440)
+#define AP1302_FLICK_CTRL_FREQ(n)		((n) << 8)
+#define AP1302_FLICK_CTRL_ETC_IHDR_UP		BIT(6)
+#define AP1302_FLICK_CTRL_ETC_DIS		BIT(5)
+#define AP1302_FLICK_CTRL_FRC_OVERRIDE_MAX_ET	BIT(4)
+#define AP1302_FLICK_CTRL_FRC_OVERRIDE_UPPER_ET	BIT(3)
+#define AP1302_FLICK_CTRL_FRC_EN		BIT(2)
+#define AP1302_FLICK_CTRL_MODE_MASK		(3U << 0)
+#define AP1302_FLICK_CTRL_MODE_DISABLED		(0U << 0)
+#define AP1302_FLICK_CTRL_MODE_MANUAL		(1U << 0)
+#define AP1302_FLICK_CTRL_MODE_AUTO		(2U << 0)
+#define AP1302_SCENE_CTRL			AP1302_REG_16BIT(0x5454)
+#define AP1302_SCENE_CTRL_MODE_MASK		0x00FF
+#define AP1302_SCENE_CTRL_MODE_NORMAL		(0U << 0)
+#define AP1302_SCENE_CTRL_MODE_PORTRAIT		(1U << 0)
+#define AP1302_SCENE_CTRL_MODE_LANDSCAPE	(2U << 0)
+#define AP1302_SCENE_CTRL_MODE_SPORT		(3U << 0)
+#define AP1302_SCENE_CTRL_MODE_CLOSE_UP		(4U << 0)
+#define AP1302_SCENE_CTRL_MODE_NIGHT		(5U << 0)
+#define AP1302_SCENE_CTRL_MODE_TWILIGHT		(6U << 0)
+#define AP1302_SCENE_CTRL_MODE_BACKLIGHT	(7U << 0)
+#define AP1302_SCENE_CTRL_MODE_HIGH_SENSITIVE	(8U << 0)
+#define AP1302_SCENE_CTRL_MODE_NIGHT_PORTRAIT	(9U << 0)
+#define AP1302_SCENE_CTRL_MODE_BEACH		(10U << 0)
+#define AP1302_SCENE_CTRL_MODE_DOCUMENT		(11U << 0)
+#define AP1302_SCENE_CTRL_MODE_PARTY		(12U << 0)
+#define AP1302_SCENE_CTRL_MODE_FIREWORKS	(13U << 0)
+#define AP1302_SCENE_CTRL_MODE_SUNSET		(14U << 0)
+#define AP1302_SCENE_CTRL_MODE_AUTO		(0xffU << 0)
+
+/* System Registers */
+#define AP1302_BOOTDATA_STAGE			AP1302_REG_16BIT(0x6002)
+#define AP1302_WARNING(n)			AP1302_REG_16BIT(0x6004 + (n) * 2)
+#define AP1302_SENSOR_SELECT			AP1302_REG_16BIT(0x600c)
+#define AP1302_SENSOR_SELECT_TP_MODE(n)		((n) << 8)
+#define AP1302_SENSOR_SELECT_PATTERN_ON		BIT(7)
+#define AP1302_SENSOR_SELECT_MODE_3D_ON		BIT(6)
+#define AP1302_SENSOR_SELECT_CLOCK_SEC		BIT(5)
+#define AP1302_SENSOR_SELECT_CLOCK_PRIM		BIT(4)
+#define AP1302_SENSOR_SELECT_RESET_SEC		BIT(3)
+#define AP1302_SENSOR_SELECT_RESET_PRIM		BIT(2)
+#define AP1302_SENSOR_SELECT_SENSOR_TP		(0U << 0)
+#define AP1302_SENSOR_SELECT_SENSOR_PRIM	(1U << 0)
+#define AP1302_SENSOR_SELECT_SENSOR_SEC		(2U << 0)
+#define AP1302_SYS_START			AP1302_REG_16BIT(0x601a)
+#define AP1302_SYS_START_PLL_LOCK		BIT(15)
+#define AP1302_SYS_START_LOAD_OTP		BIT(12)
+#define AP1302_SYS_START_RESTART_ERROR		BIT(11)
+#define AP1302_SYS_START_STALL_STATUS		BIT(9)
+#define AP1302_SYS_START_STALL_EN		BIT(8)
+#define AP1302_SYS_START_STALL_MODE_FRAME		(0U << 6)
+#define AP1302_SYS_START_STALL_MODE_DISABLED		(1U << 6)
+#define AP1302_SYS_START_STALL_MODE_STANDBY		(2U << 6)
+#define AP1302_SYS_START_STALL_MODE_STANDBY_SENSOR_OFF	(3U << 6)
+#define AP1302_SYS_START_GO			BIT(4)
+#define AP1302_SYS_START_PATCH_FUN		BIT(1)
+#define AP1302_SYS_START_PLL_INIT		BIT(0)
+#define AP1302_SYSTEM_FREQ_IN			AP1302_REG_32BIT(0x6024)
+#define AP1302_SYSTEM_FREQ_IN_MHZ(x)		((x)<<16)
+#define AP1302_HINF_MIPI_FREQ_TGT		AP1302_REG_32BIT(0x6034)
+#define AP1302_HINF_MIPI_FREQ_TGT_MHZ(x)	((x)<<16)
+
+#define AP1302_SENSOR_SIP(n)			AP1302_REG_16BIT(AP1302_PRIMARY_SENSOR_SIP + (n) * 2)
+
+#define AP1302_PRIMARY_SENSOR_SIP		AP1302_REG_16BIT(0x604A)
+#define AP1302_SECONDARY_SENSOR_SIP		AP1302_REG_32BIT(0x604C)
+
+#define AP1302_SENSOR_SIP_ID(x)			((x&0x7F)<<1)
+#define AP1302_SENSOR_SIP_AW			(1<<8)
+#define AP1302_SENSOR_SIP_DW			(1<<9)
+#define AP1302_SENSOR_SIP_SIPM			(1<<10)
+#define AP1302_SENSOR_SIP_LANES(x)		((x&0xF)<<12)
+
+#define AP1302_DMA_SRC				AP1302_REG_32BIT(0x60a0)
+#define AP1302_DMA_DST				AP1302_REG_32BIT(0x60a4)
+#define AP1302_DMA_SIP_SIPM(n)			((n) << 26)
+#define AP1302_DMA_SIP_DATA_16_BIT		BIT(25)
+#define AP1302_DMA_SIP_ADDR_16_BIT		BIT(24)
+#define AP1302_DMA_SIP_ID(n)			((n) << 17)
+#define AP1302_DMA_SIP_REG(n)			((n) << 0)
+#define AP1302_DMA_SIZE				AP1302_REG_32BIT(0x60a8)
+#define AP1302_DMA_CTRL				AP1302_REG_16BIT(0x60ac)
+#define AP1302_DMA_CTRL_SCH_NORMAL		(0 << 12)
+#define AP1302_DMA_CTRL_SCH_NEXT		(1 << 12)
+#define AP1302_DMA_CTRL_SCH_NOW			(2 << 12)
+#define AP1302_DMA_CTRL_DST_REG			(0 << 8)
+#define AP1302_DMA_CTRL_DST_SRAM		(1 << 8)
+#define AP1302_DMA_CTRL_DST_SPI			(2 << 8)
+#define AP1302_DMA_CTRL_DST_SIP			(3 << 8)
+#define AP1302_DMA_CTRL_SRC_REG			(0 << 4)
+#define AP1302_DMA_CTRL_SRC_SRAM		(1 << 4)
+#define AP1302_DMA_CTRL_SRC_SPI			(2 << 4)
+#define AP1302_DMA_CTRL_SRC_SIP			(3 << 4)
+#define AP1302_DMA_CTRL_MODE_32_BIT		BIT(3)
+#define AP1302_DMA_CTRL_MODE_MASK		(7 << 0)
+#define AP1302_DMA_CTRL_MODE_IDLE		(0 << 0)
+#define AP1302_DMA_CTRL_MODE_SET		(1 << 0)
+#define AP1302_DMA_CTRL_MODE_COPY		(2 << 0)
+#define AP1302_DMA_CTRL_MODE_MAP		(3 << 0)
+#define AP1302_DMA_CTRL_MODE_UNPACK		(4 << 0)
+#define AP1302_DMA_CTRL_MODE_OTP_READ		(5 << 0)
+#define AP1302_DMA_CTRL_MODE_SIP_PROBE		(6 << 0)
+
+#define AP1302_BOOTDATA_CHECKSUM		AP1302_REG_16BIT(0x6134)
+
+#define AP1302_BRIGHTNESS			AP1302_REG_16BIT(0x7000)
+#define AP1302_CONTRAST				AP1302_REG_16BIT(0x7002)
+#define AP1302_SATURATION			AP1302_REG_16BIT(0x7006)
+#define AP1302_GAMMA				AP1302_REG_16BIT(0x700A)
+
+/* Misc Registers */
+#define AP1302_REG_ADV_START			0xe000
+#define AP1302_ADVANCED_BASE			AP1302_REG_32BIT(0xf038)
+#define AP1302_SIP_CRC				AP1302_REG_16BIT(0xf052)
+
+/* Advanced System Registers */
+#define AP1302_ADV_IRQ_SYS_INTE			AP1302_REG_32BIT(0x00230000)
+#define AP1302_ADV_IRQ_SYS_INTE_TEST_COUNT	BIT(25)
+#define AP1302_ADV_IRQ_SYS_INTE_HINF_1		BIT(24)
+#define AP1302_ADV_IRQ_SYS_INTE_HINF_0		BIT(23)
+#define AP1302_ADV_IRQ_SYS_INTE_SINF_B_MIPI_L	(7U << 20)
+#define AP1302_ADV_IRQ_SYS_INTE_SINF_B_MIPI	BIT(19)
+#define AP1302_ADV_IRQ_SYS_INTE_SINF_A_MIPI_L	(15U << 14)
+#define AP1302_ADV_IRQ_SYS_INTE_SINF_A_MIPI	BIT(13)
+#define AP1302_ADV_IRQ_SYS_INTE_SINF		BIT(12)
+#define AP1302_ADV_IRQ_SYS_INTE_IPIPE_S		BIT(11)
+#define AP1302_ADV_IRQ_SYS_INTE_IPIPE_B		BIT(10)
+#define AP1302_ADV_IRQ_SYS_INTE_IPIPE_A		BIT(9)
+#define AP1302_ADV_IRQ_SYS_INTE_IP		BIT(8)
+#define AP1302_ADV_IRQ_SYS_INTE_TIMER		BIT(7)
+#define AP1302_ADV_IRQ_SYS_INTE_SIPM		(3U << 6)
+#define AP1302_ADV_IRQ_SYS_INTE_SIPS_ADR_RANGE	BIT(5)
+#define AP1302_ADV_IRQ_SYS_INTE_SIPS_DIRECT_WRITE	BIT(4)
+#define AP1302_ADV_IRQ_SYS_INTE_SIPS_FIFO_WRITE	BIT(3)
+#define AP1302_ADV_IRQ_SYS_INTE_SPI		BIT(2)
+#define AP1302_ADV_IRQ_SYS_INTE_GPIO_CNT	BIT(1)
+#define AP1302_ADV_IRQ_SYS_INTE_GPIO_PIN	BIT(0)
+
+/* Advanced Slave MIPI Registers */
+#define AP1302_ADV_SINF_MIPI_INTERNAL_p_LANE_n_STAT(p, n) \
+	AP1302_REG_32BIT(0x00420008 + (p) * 0x50000 + (n) * 0x20)
+#define AP1302_LANE_ERR_LP_VAL(n)		(((n) >> 30) & 3)
+#define AP1302_LANE_ERR_STATE(n)		(((n) >> 24) & 0xf)
+#define AP1302_LANE_ERR				BIT(18)
+#define AP1302_LANE_ABORT			BIT(17)
+#define AP1302_LANE_LP_VAL(n)			(((n) >> 6) & 3)
+#define AP1302_LANE_STATE(n)			((n) & 0xf)
+#define AP1302_LANE_STATE_STOP_S		0x0
+#define AP1302_LANE_STATE_HS_REQ_S		0x1
+#define AP1302_LANE_STATE_LP_REQ_S		0x2
+#define AP1302_LANE_STATE_HS_S			0x3
+#define AP1302_LANE_STATE_LP_S			0x4
+#define AP1302_LANE_STATE_ESC_REQ_S		0x5
+#define AP1302_LANE_STATE_TURN_REQ_S		0x6
+#define AP1302_LANE_STATE_ESC_S			0x7
+#define AP1302_LANE_STATE_ESC_0			0x8
+#define AP1302_LANE_STATE_ESC_1			0x9
+#define AP1302_LANE_STATE_TURN_S		0xa
+#define AP1302_LANE_STATE_TURN_MARK		0xb
+#define AP1302_LANE_STATE_ERROR_S		0xc
+
+#define AP1302_ADV_CAPTURE_A_FV_CNT		AP1302_REG_32BIT(0x00490040)
+#define AP1302_ADV_HINF_MIPI_T3			AP1302_REG_32BIT(0x840014)
+#define AP1302_TCLK_POST_MASK			0xFF
+#define AP1302_TCLK_POST_SHIFT			0x0
+#define AP1302_TCLK_PRE_MASK			0xFF00
+#define AP1302_TCLK_PRE_SHIFT			0x8
+
+// TODO This should go in v4l2-controls.h after V4L2_CID_USER_CCS_BASE
+/* The base for the AP1302 driver controls.
+ * We reserve 32 controls for this driver.
+ */
+#ifndef V4L2_CID_USER_CCS_BASE
+#define V4L2_CID_USER_CCS_BASE			(V4L2_CID_USER_BASE + 0x10f0)
+#endif
+#define V4L2_CID_USER_AP1302_BASE		(V4L2_CID_USER_CCS_BASE + 128)
+
+#define V4L2_CID_AP1302_STEREO_ORDER		(V4L2_CID_USER_AP1302_BASE + 0)
+
+struct ap1302_device;
+
+enum {
+	AP1302_PAD_SINK_0,
+	AP1302_PAD_SINK_1,
+	AP1302_PAD_SOURCE_VC0,
+	AP1302_PAD_SOURCE_VC1,
+	AP1302_PAD_SOURCE_VC2,
+	AP1302_PAD_SOURCE_VC3,
+	AP1302_PAD_MAX,
+};
+
+struct ap1302_format_info {
+	unsigned int code;
+	u16 out_fmt;
+};
+
+struct ap1302_format {
+	struct v4l2_mbus_framefmt format;
+	const struct ap1302_format_info *info;
+};
+
+struct ap1302_size {
+	unsigned int width;
+	unsigned int height;
+};
+
+struct ap1302_sensor_supply {
+	const char *name;
+	unsigned int post_delay_us;
+};
+
+struct ap1302_sensor_info {
+	const char *model;
+	struct ap1302_size resolution;
+	u32 format;
+};
+
+struct ap1302_sensor {
+	struct ap1302_device *ap1302;
+	unsigned int index;
+
+	struct device_node *of_node;
+	struct device *dev;
+	unsigned int num_supplies;
+	struct regulator_bulk_data *supplies;
+	struct ap1302_sensor_supply *supplies_data;
+
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+
+	bool link_enabled;
+	u32 sip; // XXX May need to break into SIPM, I2C Addr, ...
+};
+
+static inline struct ap1302_sensor *to_ap1302_sensor(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ap1302_sensor, sd);
+}
+
+struct ap1302_device {
+	struct device *dev;
+	struct i2c_client *client;
+
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *standby_gpio;
+	struct regulator *vcc_supply;
+	struct clk *clock;
+	struct regmap *regmap16;
+	struct regmap *regmap32;
+	u32 reg_page;
+
+	const struct firmware *fw;
+	struct nvmem_device *nvmem;
+	unsigned int fw_size;
+	u8 *fw_data;
+
+	struct v4l2_fwnode_endpoint bus_cfg;
+
+	struct mutex lock;	/* Protects formats */
+
+	struct v4l2_subdev sd;
+	struct media_pad pads[AP1302_PAD_MAX];
+	struct ap1302_format formats[AP1302_PAD_MAX];
+	unsigned int width_factor;
+	bool streaming;
+
+	struct v4l2_ctrl_handler ctrls;
+
+	struct ap1302_sensor_info sensor_info;
+	struct ap1302_sensor sensors[2];
+
+	struct {
+		struct dentry *dir;
+		struct mutex lock;
+		u32 sipm_addr;
+	} debugfs;
+
+	bool stall_standby;
+	bool use_vcid; // virtual channel
+	bool stereo_order;
+	bool primary_clk_rst_only;
+};
+
+static inline struct ap1302_device *to_ap1302(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ap1302_device, sd);
+}
+
+#define FW_MAGIC 0x33315041
+
+struct ap1302_firmware_header {
+	u32 magic;
+	u32 version;
+	char desc[256];
+	u16 pll_init_size;
+	u16 crc;
+} __packed;
+
+/**
+ * Allows specifying a firmware file when loading the module
+ */
+static char *fw_name_param;
+module_param_named(fw, fw_name_param, charp, 0444);
+
+#define MAX_FW_LOAD_RETRIES 3
+
+static const struct ap1302_format_info supported_video_formats[] = {
+	{
+		.code = MEDIA_BUS_FMT_UYVY8_1X16,
+		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
+			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_422,
+	}, {
+		.code = MEDIA_BUS_FMT_UYYVYY8_0_5X24,
+		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
+			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_420,
+	},
+#if defined(MEDIA_BUS_FMT_VYYUYY8_1X24)
+	{
+		.code = MEDIA_BUS_FMT_VYYUYY8_1X24,
+		.out_fmt = AP1302_PREVIEW_OUT_FMT_FT_YUV_JFIF
+			 | AP1302_PREVIEW_OUT_FMT_FST_YUV_420,
+	},
+#endif
+};
+
+static const struct ap1302_sensor_info ap1302_sensor_info_tpg = {
+	.model = "tpg",
+	.resolution = { 1920, 1080 },
+};
+
+/* -----------------------------------------------------------------------------
+ * Register Configuration
+ */
+
+static const struct regmap_config ap1302_reg16_config = {
+	.reg_bits = 16,
+	.val_bits = 16,
+	.reg_stride = 2,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG,
+	.cache_type = REGCACHE_NONE,
+};
+
+static const struct regmap_config ap1302_reg32_config = {
+	.reg_bits = 16,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int __ap1302_write(struct ap1302_device *ap1302, u32 reg, u32 val)
+{
+	unsigned int size = AP1302_REG_SIZE(reg);
+	u16 addr = AP1302_REG_ADDR(reg);
+	int ret;
+
+	switch (size) {
+	case 2:
+		ret = regmap_write(ap1302->regmap16, addr, val);
+		break;
+	case 4:
+		ret = regmap_write(ap1302->regmap32, addr, val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret) {
+		dev_err(ap1302->dev, "%s: register 0x%04x %s failed: %d\n",
+			__func__, addr, "write", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ap1302_write(struct ap1302_device *ap1302, u32 reg, u32 val,
+			int *err)
+{
+	u32 page = AP1302_REG_PAGE(reg);
+	int ret;
+
+	if (err && *err)
+		return *err;
+
+	if (page) {
+		if (ap1302->reg_page != page) {
+			ret = __ap1302_write(ap1302, AP1302_ADVANCED_BASE,
+					     page);
+			if (ret < 0)
+				goto done;
+
+			ap1302->reg_page = page;
+		}
+
+		reg &= ~AP1302_REG_PAGE_MASK;
+		reg += AP1302_REG_ADV_START;
+	}
+
+	ret = __ap1302_write(ap1302, reg, val);
+
+done:
+	if (err && ret)
+		*err = ret;
+
+	return ret;
+}
+
+static int __ap1302_read(struct ap1302_device *ap1302, u32 reg, u32 *val)
+{
+	unsigned int size = AP1302_REG_SIZE(reg);
+	u16 addr = AP1302_REG_ADDR(reg);
+	int ret;
+
+	switch (size) {
+	case 2:
+		ret = regmap_read(ap1302->regmap16, addr, val);
+		break;
+	case 4:
+		ret = regmap_read(ap1302->regmap32, addr, val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ret) {
+		dev_err(ap1302->dev, "%s: register 0x%04x %s failed: %d\n",
+			__func__, addr, "read", ret);
+		return ret;
+	}
+
+	dev_dbg(ap1302->dev, "%s: R0x%04x = 0x%0*x\n", __func__,
+		addr, size * 2, *val);
+
+	return 0;
+}
+
+static int ap1302_read(struct ap1302_device *ap1302, u32 reg, u32 *val)
+{
+	u32 page = AP1302_REG_PAGE(reg);
+	int ret;
+
+	if (page) {
+		if (ap1302->reg_page != page) {
+			ret = __ap1302_write(ap1302, AP1302_ADVANCED_BASE,
+					     page);
+			if (ret < 0)
+				return ret;
+
+			ap1302->reg_page = page;
+		}
+
+		reg &= ~AP1302_REG_PAGE_MASK;
+		reg += AP1302_REG_ADV_START;
+	}
+
+	return __ap1302_read(ap1302, reg, val);
+}
+
+/* Setup for regmap poll */
+static int __ap1302_poll_param(struct ap1302_device *ap1302, u32 reg,
+	struct regmap **regmap, u16 *addr)
+{
+	u32 page = AP1302_REG_PAGE(reg);
+	int ret;
+
+	if (page) {
+		if (ap1302->reg_page != page) {
+			ret = __ap1302_write(ap1302, AP1302_ADVANCED_BASE,
+					     page);
+			if (ret < 0)
+				return ret;
+
+			ap1302->reg_page = page;
+		}
+
+		reg &= ~AP1302_REG_PAGE_MASK;
+		reg += AP1302_REG_ADV_START;
+	}
+
+	*addr = AP1302_REG_ADDR(reg);
+
+	switch (AP1302_REG_SIZE(reg)) {
+	case 2:
+		*regmap = ap1302->regmap16;
+		break;
+	case 4:
+		*regmap = ap1302->regmap32;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(ap1302->dev, "%s: R0x%08x -> 0x%04x\n", __func__, reg, *addr);
+
+	return 0;
+}
+
+#define ap1302_poll_timeout(ap1302, reg, val, cond, sleep_us, timeout_us) \
+({ \
+	struct regmap *__regmap; \
+	u16 addr; \
+	int __retpoll; \
+	__retpoll = __ap1302_poll_param(ap1302, reg, &__regmap, &addr); \
+	if (!__retpoll) \
+		__retpoll = regmap_read_poll_timeout(__regmap, addr, val, cond, sleep_us, timeout_us); \
+	__retpoll; \
+})
+
+/* -----------------------------------------------------------------------------
+ * Sensor Registers Access
+ *
+ * Read and write sensor registers through the AP1302 DMA interface.
+ */
+
+static int ap1302_dma_wait_idle(struct ap1302_device *ap1302)
+{
+	unsigned int i;
+	u32 ctrl;
+	int ret;
+
+	for (i = 50; i > 0; i--) {
+		ret = ap1302_read(ap1302, AP1302_DMA_CTRL, &ctrl);
+		if (ret < 0)
+			return ret;
+
+		if ((ctrl & AP1302_DMA_CTRL_MODE_MASK) ==
+		    AP1302_DMA_CTRL_MODE_IDLE)
+			break;
+
+		usleep_range(1000, 1500);
+	}
+
+	if (!i) {
+		dev_err(ap1302->dev, "DMA timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int ap1302_sipm_read(struct ap1302_device *ap1302, unsigned int port,
+			    u32 reg, u32 *val)
+{
+	unsigned int size = AP1302_REG_SIZE(reg);
+	u32 src;
+	int ret;
+
+	if (size > 2)
+		return -EINVAL;
+
+	ret = ap1302_dma_wait_idle(ap1302);
+	if (ret < 0)
+		return ret;
+
+	// TODO Fix i2c address base on sensor
+
+	ap1302_write(ap1302, AP1302_DMA_SIZE, size, &ret);
+	src = AP1302_DMA_SIP_SIPM(port)
+	    | (size == 2 ? AP1302_DMA_SIP_DATA_16_BIT : 0)
+	    | AP1302_DMA_SIP_ADDR_16_BIT
+	    | AP1302_DMA_SIP_ID((ap1302->sensors[0].sip>>1) & 0x3F)
+	    | AP1302_DMA_SIP_REG(AP1302_REG_ADDR(reg));
+	ap1302_write(ap1302, AP1302_DMA_SRC, src, &ret);
+
+	/*
+	 * Use the AP1302_DMA_DST register as both the destination address, and
+	 * the scratch pad to store the read value.
+	 */
+	ap1302_write(ap1302, AP1302_DMA_DST, AP1302_REG_ADDR(AP1302_DMA_DST),
+		     &ret);
+
+	ap1302_write(ap1302, AP1302_DMA_CTRL,
+		     AP1302_DMA_CTRL_SCH_NORMAL |
+		     AP1302_DMA_CTRL_DST_REG |
+		     AP1302_DMA_CTRL_SRC_SIP |
+		     AP1302_DMA_CTRL_MODE_COPY, &ret);
+	if (ret < 0)
+		return ret;
+
+	ret = ap1302_dma_wait_idle(ap1302);
+	if (ret < 0)
+		return ret;
+
+	ret = ap1302_read(ap1302, AP1302_DMA_DST, val);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * The value is stored in big-endian at the DMA_DST address. The regmap
+	 * uses big-endian, so 8-bit values are stored in bits 31:24 and 16-bit
+	 * values in bits 23:16.
+	 */
+	*val >>= 32 - size * 8;
+
+	return 0;
+}
+
+static int ap1302_sipm_write(struct ap1302_device *ap1302, unsigned int port,
+			     u32 reg, u32 val)
+{
+	unsigned int size = AP1302_REG_SIZE(reg);
+	u32 dst;
+	int ret;
+
+	if (size > 2)
+		return -EINVAL;
+
+	ret = ap1302_dma_wait_idle(ap1302);
+	if (ret < 0)
+		return ret;
+
+	ap1302_write(ap1302, AP1302_DMA_SIZE, size, &ret);
+
+	/*
+	 * Use the AP1302_DMA_SRC register as both the source address, and the
+	 * scratch pad to store the write value.
+	 *
+	 * As the AP1302 uses big endian, to store the value at address DMA_SRC
+	 * it must be written in the high order bits of the registers. However,
+	 * 8-bit values seem to be incorrectly handled by the AP1302, which
+	 * expects them to be stored at DMA_SRC + 1 instead of DMA_SRC. The
+	 * value is thus unconditionally shifted by 16 bits, unlike for DMA
+	 * reads.
+	 */
+	ap1302_write(ap1302, AP1302_DMA_SRC,
+		     (val << 16) | AP1302_REG_ADDR(AP1302_DMA_SRC), &ret);
+	if (ret < 0)
+		return ret;
+
+	dst = AP1302_DMA_SIP_SIPM(port)
+	    | (size == 2 ? AP1302_DMA_SIP_DATA_16_BIT : 0)
+	    | AP1302_DMA_SIP_ADDR_16_BIT
+	    | AP1302_DMA_SIP_ID((ap1302->sensors[0].sip >> 1) & 0x3f)
+	    | AP1302_DMA_SIP_REG(AP1302_REG_ADDR(reg));
+	ap1302_write(ap1302, AP1302_DMA_DST, dst, &ret);
+
+	ap1302_write(ap1302, AP1302_DMA_CTRL,
+		     AP1302_DMA_CTRL_SCH_NORMAL |
+		     AP1302_DMA_CTRL_DST_SIP |
+		     AP1302_DMA_CTRL_SRC_REG |
+		     AP1302_DMA_CTRL_MODE_COPY, &ret);
+	if (ret < 0)
+		return ret;
+
+	ret = ap1302_dma_wait_idle(ap1302);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * Debugfs
+ */
+
+static int ap1302_sipm_addr_get(void *arg, u64 *val)
+{
+	struct ap1302_device *ap1302 = arg;
+
+	mutex_lock(&ap1302->debugfs.lock);
+	*val = ap1302->debugfs.sipm_addr;
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return 0;
+}
+
+static int ap1302_sipm_addr_set(void *arg, u64 val)
+{
+	struct ap1302_device *ap1302 = arg;
+
+	if (val & ~0x8700ffff)
+		return -EINVAL;
+
+	switch ((val >> 24) & 7) {
+	case 1:
+	case 2:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	mutex_lock(&ap1302->debugfs.lock);
+	ap1302->debugfs.sipm_addr = val;
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return 0;
+}
+
+static int ap1302_sipm_data_get(void *arg, u64 *val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 value;
+	u32 addr;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+
+	addr = ap1302->debugfs.sipm_addr;
+	if (!addr) {
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	ret = ap1302_sipm_read(ap1302, addr >> 30, addr & ~BIT(31), &value);
+	if (!ret)
+		*val = value;
+
+unlock:
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
+static int ap1302_sipm_data_set(void *arg, u64 val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 addr;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+
+	addr = ap1302->debugfs.sipm_addr;
+	if (!addr) {
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	ret = ap1302_sipm_write(ap1302, addr >> 30, addr & ~BIT(31), val);
+
+unlock:
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
+static int ap1302_mipi_tclk_post_get(void *arg, u64 *val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 value;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+
+	ret = ap1302_read(ap1302, AP1302_ADV_HINF_MIPI_T3, &value);
+	if (!ret)
+		*val = value & AP1302_TCLK_POST_MASK;
+
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
+static int ap1302_mipi_tclk_post_set(void *arg, u64 val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 reg, reg_val;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+	ret = ap1302_read(ap1302, AP1302_ADV_HINF_MIPI_T3, &reg);
+	if (ret < 0)
+		goto unlock;
+
+	reg_val = reg & ~(AP1302_TCLK_POST_MASK);
+	reg_val = reg_val | val;
+	ret = ap1302_write(ap1302, AP1302_ADV_HINF_MIPI_T3, reg_val, NULL);
+
+unlock:
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
+static int ap1302_mipi_tclk_pre_get(void *arg, u64 *val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 value;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+
+	ret = ap1302_read(ap1302, AP1302_ADV_HINF_MIPI_T3, &value);
+	if (!ret)
+		*val = (value & AP1302_TCLK_PRE_MASK) >> AP1302_TCLK_PRE_SHIFT;
+
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
+static int ap1302_mipi_tclk_pre_set(void *arg, u64 val)
+{
+	struct ap1302_device *ap1302 = arg;
+	u32 reg, reg_val;
+	int ret;
+
+	mutex_lock(&ap1302->debugfs.lock);
+	ret = ap1302_read(ap1302, AP1302_ADV_HINF_MIPI_T3, &reg);
+	if (ret < 0)
+		goto unlock;
+
+	reg_val = reg & ~(AP1302_TCLK_PRE_MASK);
+	reg_val = reg_val | val << AP1302_TCLK_PRE_SHIFT;
+	ret = ap1302_write(ap1302, AP1302_ADV_HINF_MIPI_T3, reg_val, NULL);
+
+unlock:
+	mutex_unlock(&ap1302->debugfs.lock);
+
+	return ret;
+}
+
+/*
+ * The sipm_addr and sipm_data attributes expose access to the sensor I2C bus.
+ *
+ * To read or write a register, sipm_addr has to first be written with the
+ * register address. The address is a 32-bit integer formatted as follows.
+ *
+ * I000 0SSS 0000 0000 RRRR RRRR RRRR RRRR
+ *
+ * I: SIPM index (0 or 1)
+ * S: Size (1: 8-bit, 2: 16-bit)
+ * R: Register address (16-bit)
+ *
+ * The sipm_data attribute can then be read to read the register value, or
+ * written to write it.
+ */
+
+DEFINE_DEBUGFS_ATTRIBUTE(ap1302_sipm_addr_fops, ap1302_sipm_addr_get,
+			 ap1302_sipm_addr_set, "0x%08llx\n");
+DEFINE_DEBUGFS_ATTRIBUTE(ap1302_sipm_data_fops, ap1302_sipm_data_get,
+			 ap1302_sipm_data_set, "0x%08llx\n");
+
+/* The debugfs is to read and write mipi clk parameters tclk_post values */
+DEFINE_DEBUGFS_ATTRIBUTE(ap1302_mipi_tclk_post_fops, ap1302_mipi_tclk_post_get,
+			 ap1302_mipi_tclk_post_set, "0x%08llx\n");
+
+/* The debugfs is to read and write mipi clk parameters and tclk_pre values */
+DEFINE_DEBUGFS_ATTRIBUTE(ap1302_mipi_tclk_pre_fops, ap1302_mipi_tclk_pre_get,
+			 ap1302_mipi_tclk_pre_set, "0x%08llx\n");
+
+static void ap1302_debugfs_init(struct ap1302_device *ap1302)
+{
+	struct dentry *dir;
+	char name[16];
+
+	mutex_init(&ap1302->debugfs.lock);
+
+	snprintf(name, sizeof(name), "ap1302.%s", dev_name(ap1302->dev));
+
+	dir = debugfs_create_dir(name, NULL);
+	if (IS_ERR(dir))
+		return;
+
+	ap1302->debugfs.dir = dir;
+
+	debugfs_create_file_unsafe("sipm_addr", 0600, ap1302->debugfs.dir,
+				   ap1302, &ap1302_sipm_addr_fops);
+	debugfs_create_file_unsafe("sipm_data", 0600, ap1302->debugfs.dir,
+				   ap1302, &ap1302_sipm_data_fops);
+	debugfs_create_file_unsafe("mipi_tclk_post", 0600, ap1302->debugfs.dir,
+				   ap1302, &ap1302_mipi_tclk_post_fops);
+	debugfs_create_file_unsafe("mipi_tclk_pre", 0600, ap1302->debugfs.dir,
+				   ap1302, &ap1302_mipi_tclk_pre_fops);
+}
+
+static void ap1302_debugfs_cleanup(struct ap1302_device *ap1302)
+{
+	debugfs_remove_recursive(ap1302->debugfs.dir);
+	mutex_destroy(&ap1302->debugfs.lock);
+}
+
+/* -----------------------------------------------------------------------------
+ * Power Handling
+ */
+
+static int ap1302_power_on_sensors(struct ap1302_device *ap1302)
+{
+	struct ap1302_sensor *sensor;
+	unsigned int i, j;
+	int ret;
+
+	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
+		sensor = &ap1302->sensors[i];
+		ret = 0;
+
+		for (j = 0; j < sensor->num_supplies; ++j) {
+			unsigned int delay;
+
+			/*
+			 * We can't use regulator_bulk_enable() as it would
+			 * enable all supplies in parallel, breaking the sensor
+			 * power sequencing constraints.
+			 */
+			ret = regulator_enable(sensor->supplies[j].consumer);
+			if (ret < 0) {
+				dev_err(ap1302->dev,
+					"Failed to enable supply %u for sensor %u\n",
+					j, i);
+				goto error;
+			}
+
+			delay = sensor->supplies_data[j].post_delay_us;
+			usleep_range(delay, delay + 100);
+		}
+	}
+
+	return 0;
+
+error:
+	for (; j > 0; --j)
+		regulator_disable(sensor->supplies[j - 1].consumer);
+
+	for (; i > 0; --i) {
+		sensor = &ap1302->sensors[i - 1];
+		regulator_bulk_disable(sensor->num_supplies, sensor->supplies);
+	}
+
+	return ret;
+}
+
+static void ap1302_power_off_sensors(struct ap1302_device *ap1302)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
+		struct ap1302_sensor *sensor = &ap1302->sensors[i];
+
+		regulator_bulk_disable(sensor->num_supplies, sensor->supplies);
+	}
+}
+
+static int ap1302_power_on(struct ap1302_device *ap1302)
+{
+	int ret;
+
+	/* 0. RESET was asserted when getting the GPIO. */
+
+	/* 1. Assert STANDBY. */
+	if (ap1302->standby_gpio) {
+		gpiod_set_value(ap1302->standby_gpio, 1);
+		usleep_range(200, 1000);
+	}
+
+	/* 2. Power up the regulators. */
+	if (ap1302->vcc_supply) {
+		ret = regulator_enable(ap1302->vcc_supply);
+		if (ret < 0) {
+			dev_err(ap1302->dev, "Failed to enable vcc supply: %d\n", ret);
+			return ret;
+		}
+		usleep_range(200, 1000);
+	}
+
+	/* 3. De-assert STANDBY. */
+	if (ap1302->standby_gpio) {
+		gpiod_set_value(ap1302->standby_gpio, 0);
+		usleep_range(200, 1000);
+	}
+
+	/* 4. Turn the clock on. */
+	if (ap1302->clock) {
+		ret = clk_prepare_enable(ap1302->clock);
+		if (ret < 0) {
+			dev_err(ap1302->dev, "Failed to enable clock: %d\n", ret);
+			return ret;
+		}
+		/* Allow clock to setup */
+		usleep_range(200, 1000);
+	}
+
+	/* 5. De-assert RESET. */
+	gpiod_set_value(ap1302->reset_gpio, 0);
+
+	/*
+	 * 6. Wait for the AP1302 to initialize. The datasheet doesn't specify
+	 * how long this takes.
+	 */
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static void ap1302_power_off(struct ap1302_device *ap1302)
+{
+	/* 1. Assert RESET. */
+	gpiod_set_value(ap1302->reset_gpio, 1);
+
+	/* Allow Reset to occur */
+	usleep_range(200, 1000);
+
+	/* 2. Turn the clock off. */
+	clk_disable_unprepare(ap1302->clock);
+
+	/* 3. Assert STANDBY. */
+	if (ap1302->standby_gpio) {
+		gpiod_set_value(ap1302->standby_gpio, 1);
+		usleep_range(200, 1000);
+	}
+
+	/* 4. Power down the regulators. */
+	if (ap1302->vcc_supply) {
+		regulator_disable(ap1302->vcc_supply);
+		usleep_range(200, 1000);
+	}
+
+	/* 5. De-assert STANDBY. */
+	if (ap1302->standby_gpio) {
+		usleep_range(200, 1000);
+		gpiod_set_value(ap1302->standby_gpio, 0);
+	}
+}
+
+/* -----------------------------------------------------------------------------
+ * Hardware Configuration
+ */
+
+static int ap1302_dump_console(struct ap1302_device *ap1302)
+{
+	u8 *buffer;
+	u8 *endp;
+	u8 *p;
+	int ret;
+
+	buffer = kmalloc(AP1302_CON_BUF_SIZE + 1, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	// XXX use CON_WP, CON_RP see AP1302-Rev2.ini
+
+	// 256 16-bit register : 512 bytes
+	ret = regmap_raw_read(ap1302->regmap16, AP1302_CON_BUF(0), buffer,
+			      AP1302_CON_BUF_SIZE/2);
+	if (ret < 0) {
+		dev_err(ap1302->dev, "Failed to read console buffer: %d\n", ret);
+		goto done;
+	}
+
+	buffer[AP1302_CON_BUF_SIZE] = '\0';
+
+	for (p = buffer; p < buffer + AP1302_CON_BUF_SIZE && *p; p = endp + 1) {
+		endp = strchrnul(p, '\n');
+		*endp = '\0';
+
+		dev_info(ap1302->dev, "log > %s\n", p);
+	}
+
+	ret = 0;
+
+done:
+	kfree(buffer);
+	return ret;
+}
+
+static u16 ap1302_width_factor(struct ap1302_device *ap1302)
+{
+	/*
+	 * Width factor depends on the number of camera links
+	 */
+
+	u16 width_factor = 0;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i)
+		width_factor += ap1302->sensors[i].link_enabled;
+
+	if (width_factor == 0 || ap1302->use_vcid)
+		width_factor = 1;
+
+	dev_dbg(ap1302->dev, "width_factor %d\n", width_factor);
+
+	return width_factor;
+}
+
+static int ap1302_configure(struct ap1302_device *ap1302)
+{
+	const struct ap1302_format *format = &ap1302->formats[AP1302_PAD_SOURCE_VC0];
+	unsigned int data_lanes = ap1302->bus_cfg.bus.mipi_csi2.num_data_lanes;
+	int ret = 0;
+	u16 width_factor = ap1302_width_factor(ap1302);
+	u8 sensor_link = ((!!ap1302->sensors[1].link_enabled) << 1) |
+		!!ap1302->sensors[0].link_enabled;
+
+
+	u32 value = AP1302_PREVIEW_HINF_CTRL_SPOOF |
+		AP1302_PREVIEW_HINF_CTRL_MIPI_LANES(data_lanes);
+
+	if (ap1302->use_vcid)
+		value |= AP1302_PREVIEW_HINF_CTRL_MIPI_MODE;
+
+	ap1302_write(ap1302, AP1302_PREVIEW_HINF_CTRL, value, &ret);
+
+	value =  AP1302_SENSOR_SELECT_TP_MODE(4);
+
+	switch (sensor_link) {
+	case 0:
+		value |= AP1302_SENSOR_SELECT_PATTERN_ON |
+			AP1302_SENSOR_SELECT_SENSOR_TP;
+		break;
+	case 1:
+		value |= AP1302_SENSOR_SELECT_SENSOR_PRIM |
+			AP1302_SENSOR_SELECT_RESET_PRIM |
+			AP1302_SENSOR_SELECT_CLOCK_PRIM;
+		break;
+	case 2:
+		value |= AP1302_SENSOR_SELECT_SENSOR_SEC;
+		if (ap1302->primary_clk_rst_only) {
+			value |= AP1302_SENSOR_SELECT_RESET_PRIM |
+				AP1302_SENSOR_SELECT_CLOCK_PRIM;
+		} else {
+			value |= AP1302_SENSOR_SELECT_RESET_SEC |
+				AP1302_SENSOR_SELECT_CLOCK_SEC;
+		}
+		break;
+	case 3:
+		if (ap1302->use_vcid)
+			value |= AP1302_SENSOR_SELECT_SENSOR_PRIM;
+		else
+			value |= ap1302->stereo_order ?
+				AP1302_SENSOR_SELECT_SENSOR_SEC :
+				AP1302_SENSOR_SELECT_SENSOR_PRIM;
+
+		value |= AP1302_SENSOR_SELECT_RESET_PRIM |
+			AP1302_SENSOR_SELECT_CLOCK_PRIM |
+			AP1302_SENSOR_SELECT_MODE_3D_ON;
+
+		if (!ap1302->primary_clk_rst_only)  {
+			value |= AP1302_SENSOR_SELECT_RESET_SEC |
+				AP1302_SENSOR_SELECT_CLOCK_SEC;
+		}
+		break;
+	}
+
+	dev_dbg(ap1302->dev, "Sensor Link %d Select 0x%x\n",
+		 sensor_link, value);
+	ap1302_write(ap1302, AP1302_SENSOR_SELECT, value, &ret);
+
+	ap1302_write(ap1302, AP1302_PREVIEW_WIDTH,
+		     format->format.width / width_factor, &ret);
+	ap1302_write(ap1302, AP1302_PREVIEW_HEIGHT,
+		     format->format.height, &ret);
+	ap1302_write(ap1302, AP1302_PREVIEW_OUT_FMT,
+		     format->info->out_fmt, &ret);
+	if (ret < 0)
+		return ret;
+
+	__v4l2_ctrl_handler_setup(&ap1302->ctrls);
+
+	return 0;
+}
+
+static int ap1302_stall(struct ap1302_device *ap1302, bool stall)
+{
+	u32 value;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_SYS_START, &value);
+	if (ret < 0)
+		return ret;
+
+	if (!!(value & AP1302_SYS_START_STALL_STATUS) == stall) {
+		dev_warn(ap1302->dev,
+			 "Stall status already as requested : %s\n",
+			 stall ? "stalled" : "running");
+		return 0;
+	}
+
+	if (stall) {
+		if (ap1302->stall_standby)
+			dev_info(ap1302->dev, "Standby, sensor shutdown stall mode\n");
+
+		ap1302_write(ap1302, AP1302_SYS_START, AP1302_SYS_START_STALL_EN |
+			     (ap1302->stall_standby ?
+			     AP1302_SYS_START_STALL_MODE_STANDBY_SENSOR_OFF :
+			     AP1302_SYS_START_STALL_MODE_DISABLED), &ret);
+		if (ret < 0)
+			return ret;
+
+		/*
+		 * Wait for Stall Status
+		 */
+		ret = ap1302_poll_timeout(ap1302, AP1302_SYS_START, value,
+			value & AP1302_SYS_START_STALL_STATUS, 10000, 5000000);
+		if (ret) {
+			dev_err(ap1302->dev, "Stall Failed: %d\n", ret);
+			return ret;
+		}
+
+		ap1302->streaming = false;
+	} else {
+		ap1302->streaming = true;
+
+		ap1302_write(ap1302, AP1302_SYS_START,
+			     AP1302_SYS_START_STALL_EN |
+			     AP1302_SYS_START_STALL_MODE_DISABLED, &ret);
+		if (ret < 0)
+			return ret;
+
+		/*
+		 * Wait for Stall Status
+		 */
+		ret = ap1302_poll_timeout(ap1302, AP1302_SYS_START, value,
+			!(value & AP1302_SYS_START_STALL_STATUS),
+			10000, 5000000);
+		if (ret) {
+			dev_err(ap1302->dev, "Stall Failed: %d\n", ret);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int ap1302_set_mipi_t3_clk(struct ap1302_device *ap1302)
+{
+	unsigned int mipi_t3, t_clk_post, t_clk_pre;
+	int ret;
+
+	/* Set the Tclk_post and Tclk_pre values */
+	ret = ap1302_read(ap1302, AP1302_ADV_HINF_MIPI_T3, &mipi_t3);
+	if (ret)
+		return ret;
+
+	/* Read Tclk post default setting and increment by 2 */
+	t_clk_post = ((mipi_t3 & AP1302_TCLK_POST_MASK)
+					>> AP1302_TCLK_POST_SHIFT) + 0x5;
+	/* Read Tclk pre default setting and increment by 1 */
+	t_clk_pre = ((mipi_t3 & AP1302_TCLK_PRE_MASK)
+					>> AP1302_TCLK_PRE_SHIFT) + 0x1;
+
+	mipi_t3 = ((mipi_t3 & ~(AP1302_TCLK_POST_MASK))
+					& ~(AP1302_TCLK_PRE_MASK));
+	mipi_t3 = (mipi_t3 | (t_clk_pre << AP1302_TCLK_PRE_SHIFT)
+					| t_clk_post);
+
+	/* Write MIPI_T3 register with updated Tclk_post and Tclk_pre values */
+	return ap1302_write(ap1302, AP1302_ADV_HINF_MIPI_T3, mipi_t3, NULL);
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Controls
+ */
+
+static u16 ap1302_wb_values[] = {
+	AP1302_AWB_CTRL_MODE_OFF,	/* V4L2_WHITE_BALANCE_MANUAL */
+	AP1302_AWB_CTRL_MODE_AUTO,	/* V4L2_WHITE_BALANCE_AUTO */
+	AP1302_AWB_CTRL_MODE_A,		/* V4L2_WHITE_BALANCE_INCANDESCENT */
+	AP1302_AWB_CTRL_MODE_D50,	/* V4L2_WHITE_BALANCE_FLUORESCENT */
+	AP1302_AWB_CTRL_MODE_D65,	/* V4L2_WHITE_BALANCE_FLUORESCENT_H */
+	AP1302_AWB_CTRL_MODE_HORIZON,	/* V4L2_WHITE_BALANCE_HORIZON */
+	AP1302_AWB_CTRL_MODE_D65,	/* V4L2_WHITE_BALANCE_DAYLIGHT */
+	AP1302_AWB_CTRL_MODE_AUTO,	/* V4L2_WHITE_BALANCE_FLASH */
+	AP1302_AWB_CTRL_MODE_D75,	/* V4L2_WHITE_BALANCE_CLOUDY */
+	AP1302_AWB_CTRL_MODE_D75,	/* V4L2_WHITE_BALANCE_SHADE */
+};
+
+static int ap1302_set_wb_mode(struct ap1302_device *ap1302, s32 mode)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_AWB_CTRL, &val);
+	if (ret)
+		return ret;
+
+	val &= ~AP1302_AWB_CTRL_MODE_MASK;
+	val |= ap1302_wb_values[mode];
+
+	if (mode == V4L2_WHITE_BALANCE_FLASH)
+		val |= AP1302_AWB_CTRL_FLASH;
+	else
+		val &= ~AP1302_AWB_CTRL_FLASH;
+
+	return ap1302_write(ap1302, AP1302_AWB_CTRL, val, NULL);
+}
+
+static int ap1302_get_wb_mode(struct ap1302_device *ap1302, s32 *mode)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_AWB_CTRL, &val);
+	if (ret)
+		return ret;
+
+	val &= AP1302_AWB_CTRL_MODE_MASK;
+	*mode = 0; // Default to V4L2_WHITE_BALANCE_MANUAL
+
+	for (ret = 0; ret < ARRAY_SIZE(ap1302_wb_values); ret++) {
+		if (val == ap1302_wb_values[ret]) {
+			*mode = ret;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int ap1302_set_exposure(struct ap1302_device *ap1302, s32 mode)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_AE_CTRL, &val);
+	if (ret)
+		return ret;
+
+	val &= ~AP1302_AE_CTRL_MODE_MASK;
+	val |= mode;
+
+	return ap1302_write(ap1302, AP1302_AE_CTRL, val, NULL);
+}
+
+static int ap1302_get_exposure(struct ap1302_device *ap1302, s32 *mode)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_AE_CTRL, &val);
+	if (ret)
+		return ret;
+
+	*mode = val & AP1302_AE_CTRL_MODE_MASK;
+
+	return 0;
+}
+
+static int ap1302_set_exp_met(struct ap1302_device *ap1302, s32 val)
+{
+	return ap1302_write(ap1302, AP1302_AE_MET, val, NULL);
+}
+
+static int ap1302_get_exp_met(struct ap1302_device *ap1302, s32 *value)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_AE_MET, &val);
+	if (ret)
+		return ret;
+
+	*value = val & AP1302_AE_MET_MASK;
+
+	return 0;
+}
+
+static int ap1302_set_gain(struct ap1302_device *ap1302, s32 val)
+{
+	// Format is U8.8
+	return ap1302_write(ap1302, AP1302_AE_MANUAL_GAIN, val, NULL);
+}
+
+static int ap1302_get_gain(struct ap1302_device *ap1302, s32 *value)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_AE_MANUAL_GAIN, &val);
+	if (ret)
+		return ret;
+
+	*value = val & AP1302_AE_MANUAL_GAIN_MASK;
+
+	return 0;
+}
+
+static int ap1302_set_hflip(struct ap1302_device *ap1302, s32 flip)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_ORIENTATION, &val);
+	if (ret)
+		return ret;
+
+	val &= ~AP1302_ORIENTATION_HFLIP;
+	val |= flip ? AP1302_ORIENTATION_HFLIP : 0;
+
+	return ap1302_write(ap1302, AP1302_ORIENTATION, val, NULL);
+}
+
+static int ap1302_get_hflip(struct ap1302_device *ap1302, s32 *flip)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_ORIENTATION, &val);
+	if (ret)
+		return ret;
+
+	*flip = !!(val & AP1302_ORIENTATION_HFLIP);
+
+	return 0;
+}
+
+static int ap1302_set_vflip(struct ap1302_device *ap1302, s32 flip)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_ORIENTATION, &val);
+	if (ret)
+		return ret;
+
+	val &= ~AP1302_ORIENTATION_VFLIP;
+	val |= flip?AP1302_ORIENTATION_VFLIP:0;
+
+	return ap1302_write(ap1302, AP1302_ORIENTATION, val, NULL);
+}
+
+static int ap1302_get_vflip(struct ap1302_device *ap1302, s32 *flip)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_ORIENTATION, &val);
+	if (ret)
+		return ret;
+
+	*flip = !!(val & AP1302_ORIENTATION_VFLIP);
+
+	return 0;
+}
+
+static int ap1302_set_contrast(struct ap1302_device *ap1302, s32 val)
+{
+	// Format is s3.12
+	return ap1302_write(ap1302, AP1302_CONTRAST, val, NULL);
+}
+
+static int ap1302_get_contrast(struct ap1302_device *ap1302, s32 *value)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_CONTRAST, &val);
+	if (ret)
+		return ret;
+
+	*value = val;
+
+	return 0;
+}
+
+static int ap1302_set_brightness(struct ap1302_device *ap1302, s32 val)
+{
+	// Format is s3.12
+	return ap1302_write(ap1302, AP1302_BRIGHTNESS, val, NULL);
+}
+
+static int ap1302_get_brightness(struct ap1302_device *ap1302, s32 *value)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_BRIGHTNESS, &val);
+	if (ret)
+		return ret;
+
+	*value = val;
+
+	return 0;
+}
+
+static int ap1302_set_saturation(struct ap1302_device *ap1302, s32 val)
+{
+	// Format is s3.12
+	return ap1302_write(ap1302, AP1302_SATURATION, val, NULL);
+}
+
+static int ap1302_get_saturation(struct ap1302_device *ap1302, s32 *value)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_SATURATION, &val);
+	if (ret)
+		return ret;
+
+	*value = val;
+
+	return 0;
+}
+
+static int ap1302_set_gamma(struct ap1302_device *ap1302, s32 val)
+{
+	// Format is s3.12
+	return ap1302_write(ap1302, AP1302_GAMMA, val, NULL);
+}
+
+static int ap1302_get_gamma(struct ap1302_device *ap1302, s32 *value)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_GAMMA, &val);
+	if (ret)
+		return ret;
+
+	*value = val;
+
+	return 0;
+}
+
+static int ap1302_set_zoom(struct ap1302_device *ap1302, s32 val)
+{
+	// Format s7.8
+	return ap1302_write(ap1302, AP1302_DZ_TGT_FCT, val, NULL);
+}
+
+static int ap1302_get_zoom(struct ap1302_device *ap1302, s32 *value)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_DZ_TGT_FCT, &val);
+	if (ret)
+		return ret;
+
+	*value = val;
+
+	return 0;
+}
+
+static u16 ap1302_sfx_values[] = {
+	AP1302_SFX_MODE_SFX_NORMAL,	/* V4L2_COLORFX_NONE */
+	AP1302_SFX_MODE_SFX_BW,		/* V4L2_COLORFX_BW */
+	AP1302_SFX_MODE_SFX_SEPIA1,	/* V4L2_COLORFX_SEPIA */
+	AP1302_SFX_MODE_SFX_NEGATIVE,	/* V4L2_COLORFX_NEGATIVE */
+	AP1302_SFX_MODE_SFX_EMBOSS,	/* V4L2_COLORFX_EMBOSS */
+	AP1302_SFX_MODE_SFX_SKETCH,	/* V4L2_COLORFX_SKETCH */
+	AP1302_SFX_MODE_SFX_BLUISH,	/* V4L2_COLORFX_SKY_BLUE */
+	AP1302_SFX_MODE_SFX_GREENISH,	/* V4L2_COLORFX_GRASS_GREEN */
+	AP1302_SFX_MODE_SFX_REDISH,	/* V4L2_COLORFX_SKIN_WHITEN */
+	AP1302_SFX_MODE_SFX_NORMAL,	/* V4L2_COLORFX_VIVID */
+	AP1302_SFX_MODE_SFX_NORMAL,	/* V4L2_COLORFX_AQUA */
+	AP1302_SFX_MODE_SFX_NORMAL,	/* V4L2_COLORFX_ART_FREEZE */
+	AP1302_SFX_MODE_SFX_NORMAL,	/* V4L2_COLORFX_SILHOUETTE */
+	AP1302_SFX_MODE_SFX_SOLARIZE,	/* V4L2_COLORFX_SOLARIZATION */
+	AP1302_SFX_MODE_SFX_ANTIQUE,	/* V4L2_COLORFX_ANTIQUE */
+	AP1302_SFX_MODE_SFX_NORMAL,	/* V4L2_COLORFX_SET_CBCR */
+};
+
+static int ap1302_set_special_effect(struct ap1302_device *ap1302, s32 val)
+{
+	return ap1302_write(ap1302, AP1302_SFX_MODE,
+			    ap1302_sfx_values[val] & AP1302_SFX_MODE_SFX_MASK,
+			    NULL);
+}
+
+static int ap1302_get_special_effect(struct ap1302_device *ap1302, s32 *mode)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_SFX_MODE, &val);
+	if (ret)
+		return ret;
+
+	val &= AP1302_SFX_MODE_SFX_MASK;
+
+	*mode = V4L2_COLORFX_NONE; // Default
+
+	for (ret = 0; ret < ARRAY_SIZE(ap1302_sfx_values); ret++) {
+		if (val == ap1302_sfx_values[ret]) {
+			*mode = ret;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static u16 ap1302_scene_mode_values[] = {
+	AP1302_SCENE_CTRL_MODE_NORMAL,		/* V4L2_SCENE_MODE_NONE */
+	AP1302_SCENE_CTRL_MODE_BACKLIGHT,	/* V4L2_SCENE_MODE_BACKLIGHT */
+	AP1302_SCENE_CTRL_MODE_BEACH,		/* V4L2_SCENE_MODE_BEACH_SNOW */
+	AP1302_SCENE_CTRL_MODE_TWILIGHT,	/* V4L2_SCENE_MODE_CANDLE_LIGHT */
+	AP1302_SCENE_CTRL_MODE_NORMAL,		/* V4L2_SCENE_MODE_DAWN_DUSK */
+	AP1302_SCENE_CTRL_MODE_NORMAL,		/* V4L2_SCENE_MODE_FALL_COLORS */
+	AP1302_SCENE_CTRL_MODE_FIREWORKS,	/* V4L2_SCENE_MODE_FIREWORKS */
+	AP1302_SCENE_CTRL_MODE_LANDSCAPE,	/* V4L2_SCENE_MODE_LANDSCAPE */
+	AP1302_SCENE_CTRL_MODE_NIGHT,		/* V4L2_SCENE_MODE_NIGHT */
+	AP1302_SCENE_CTRL_MODE_PARTY,		/* V4L2_SCENE_MODE_PARTY_INDOOR */
+	AP1302_SCENE_CTRL_MODE_PORTRAIT,	/* V4L2_SCENE_MODE_PORTRAIT */
+	AP1302_SCENE_CTRL_MODE_SPORT,		/* V4L2_SCENE_MODE_SPORTS */
+	AP1302_SCENE_CTRL_MODE_SUNSET,		/* V4L2_SCENE_MODE_SUNSET */
+	AP1302_SCENE_CTRL_MODE_DOCUMENT,	/* V4L2_SCENE_MODE_TEXT */
+};
+
+static int ap1302_set_scene_mode(struct ap1302_device *ap1302, s32 val)
+{
+	return ap1302_write(ap1302, AP1302_SCENE_CTRL,
+			    ap1302_scene_mode_values[val] & AP1302_SCENE_CTRL_MODE_MASK, NULL);
+}
+
+static int ap1302_get_scene_mode(struct ap1302_device *ap1302, s32 *mode)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_SCENE_CTRL, &val);
+	if (ret)
+		return ret;
+
+	val &= AP1302_SCENE_CTRL_MODE_MASK;
+
+	*mode = V4L2_SCENE_MODE_NONE; // Default
+
+	for (ret = 0; ret < ARRAY_SIZE(ap1302_scene_mode_values); ret++) {
+		if (val == ap1302_scene_mode_values[ret]) {
+			*mode = ret;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static const u16 ap1302_flicker_values[] = {
+	AP1302_FLICK_CTRL_MODE_DISABLED,
+	AP1302_FLICK_CTRL_FREQ(50) | AP1302_FLICK_CTRL_MODE_MANUAL,
+	AP1302_FLICK_CTRL_FREQ(60) | AP1302_FLICK_CTRL_MODE_MANUAL,
+	AP1302_FLICK_CTRL_MODE_AUTO,
+};
+
+static int ap1302_set_flicker_freq(struct ap1302_device *ap1302, s32 val)
+{
+	return ap1302_write(ap1302, AP1302_FLICK_CTRL,
+			    ap1302_flicker_values[val], NULL);
+}
+
+static int ap1302_get_flicker_freq(struct ap1302_device *ap1302, s32 *value)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_FLICK_CTRL, &val);
+	if (ret)
+		return ret;
+
+	*value = V4L2_CID_POWER_LINE_FREQUENCY_AUTO; // Default
+
+
+	if ((val & AP1302_FLICK_CTRL_MODE_MASK) ==
+			AP1302_FLICK_CTRL_MODE_DISABLED) {
+		*value = V4L2_CID_POWER_LINE_FREQUENCY_DISABLED;
+	} else if ((val & AP1302_FLICK_CTRL_MODE_MASK) ==
+			AP1302_FLICK_CTRL_MODE_MANUAL) {
+		if ((val >> 8) == 50)
+			*value = V4L2_CID_POWER_LINE_FREQUENCY_50HZ;
+		if ((val >> 8) == 60)
+			*value = V4L2_CID_POWER_LINE_FREQUENCY_60HZ;
+
+	} else if ((val & AP1302_FLICK_CTRL_MODE_MASK) ==
+			AP1302_FLICK_CTRL_MODE_AUTO) {
+		*value = V4L2_CID_POWER_LINE_FREQUENCY_AUTO;
+	}
+
+	return 0;
+}
+
+static int ap1302_set_auto_focus(struct ap1302_device *ap1302, s32 mode)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_AF_CTRL, &val);
+	if (ret)
+		return ret;
+
+	val &= ~(AP1302_AF_CTRL_MODE_MASK|AP1302_AF_CTRL_TRIGGER);
+	if (mode)
+		val |= AP1302_AF_CTRL_MODE_AUTO|AP1302_AF_CTRL_TRIGGER;
+
+	return ap1302_write(ap1302, AP1302_AF_CTRL, val, NULL);
+}
+
+static int ap1302_get_auto_focus(struct ap1302_device *ap1302, s32 *mode)
+{
+	u32 val;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_AF_CTRL, &val);
+	if (ret)
+		return ret;
+
+	*mode = (val & AP1302_AF_CTRL_MODE_MASK) == AP1302_AF_CTRL_MODE_AUTO ? 1 : 0;
+
+	return 0;
+}
+
+static int ap1302_set_stereo_order(struct ap1302_device *ap1302, s32 path)
+{
+	ap1302->stereo_order = !!path;
+
+	return 0;
+}
+
+static int ap1302_get_stereo_order(struct ap1302_device *ap1302, s32 *path)
+{
+	*path = ap1302->stereo_order;
+
+	return 0;
+}
+
+static int ap1302_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ap1302_device *ap1302 =
+		container_of(ctrl->handler, struct ap1302_device, ctrls);
+
+	switch (ctrl->id) {
+	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+		return ap1302_set_wb_mode(ap1302, ctrl->val);
+
+	case V4L2_CID_EXPOSURE:
+		return ap1302_set_exposure(ap1302, ctrl->val);
+
+	case V4L2_CID_EXPOSURE_METERING:
+		return ap1302_set_exp_met(ap1302, ctrl->val);
+
+	case V4L2_CID_GAIN:
+		return ap1302_set_gain(ap1302, ctrl->val);
+
+	case V4L2_CID_HFLIP:
+		return ap1302_set_hflip(ap1302, ctrl->val);
+
+	case V4L2_CID_VFLIP:
+		return ap1302_set_vflip(ap1302, ctrl->val);
+
+	case V4L2_CID_GAMMA:
+		return ap1302_set_gamma(ap1302, ctrl->val);
+
+	case V4L2_CID_CONTRAST:
+		return ap1302_set_contrast(ap1302, ctrl->val);
+
+	case V4L2_CID_BRIGHTNESS:
+		return ap1302_set_brightness(ap1302, ctrl->val);
+
+	case V4L2_CID_SATURATION:
+		return ap1302_set_saturation(ap1302, ctrl->val);
+
+	case V4L2_CID_ZOOM_ABSOLUTE:
+		return ap1302_set_zoom(ap1302, ctrl->val);
+
+	case V4L2_CID_COLORFX:
+		return ap1302_set_special_effect(ap1302, ctrl->val);
+
+	case V4L2_CID_SCENE_MODE:
+		return ap1302_set_scene_mode(ap1302, ctrl->val);
+
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		return ap1302_set_flicker_freq(ap1302, ctrl->val);
+
+	case V4L2_CID_FOCUS_AUTO:
+		return ap1302_set_auto_focus(ap1302, ctrl->val);
+
+	case V4L2_CID_AP1302_STEREO_ORDER:
+		return ap1302_set_stereo_order(ap1302, ctrl->val);
+
+	default:
+		dev_dbg(ap1302->dev, "Unknown control 0x%x\n", ctrl->id);
+		return -EINVAL;
+	}
+}
+
+static int ap1302_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ap1302_device *ap1302 =
+		container_of(ctrl->handler, struct ap1302_device, ctrls);
+
+	switch (ctrl->id) {
+	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+		return ap1302_get_wb_mode(ap1302, &ctrl->val);
+
+	case V4L2_CID_EXPOSURE:
+		return ap1302_get_exposure(ap1302, &ctrl->val);
+
+	case V4L2_CID_EXPOSURE_METERING:
+		return ap1302_get_exp_met(ap1302, &ctrl->val);
+
+	case V4L2_CID_GAIN:
+		return ap1302_get_gain(ap1302, &ctrl->val);
+
+	case V4L2_CID_HFLIP:
+		return ap1302_get_hflip(ap1302, &ctrl->val);
+
+	case V4L2_CID_VFLIP:
+		return ap1302_get_vflip(ap1302, &ctrl->val);
+
+	case V4L2_CID_GAMMA:
+		return ap1302_get_gamma(ap1302, &ctrl->val);
+
+	case V4L2_CID_CONTRAST:
+		return ap1302_get_contrast(ap1302, &ctrl->val);
+
+	case V4L2_CID_BRIGHTNESS:
+		return ap1302_get_brightness(ap1302, &ctrl->val);
+
+	case V4L2_CID_SATURATION:
+		return ap1302_get_saturation(ap1302, &ctrl->val);
+
+	case V4L2_CID_ZOOM_ABSOLUTE:
+		return ap1302_get_zoom(ap1302, &ctrl->val);
+
+	case V4L2_CID_COLORFX:
+		return ap1302_get_special_effect(ap1302, &ctrl->val);
+
+	case V4L2_CID_SCENE_MODE:
+		return ap1302_get_scene_mode(ap1302, &ctrl->val);
+
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		return ap1302_get_flicker_freq(ap1302, &ctrl->val);
+
+	case V4L2_CID_FOCUS_AUTO:
+		return ap1302_get_auto_focus(ap1302, &ctrl->val);
+
+	case V4L2_CID_AP1302_STEREO_ORDER:
+		return ap1302_get_stereo_order(ap1302, &ctrl->val);
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct v4l2_ctrl_ops ap1302_ctrl_ops = {
+	.s_ctrl = ap1302_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config ap1302_ctrls[] = {
+	{
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
+		.min = 0,
+		.max = 9,
+		.def = 1,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_GAMMA,
+		.name = "Gamma",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0x0,
+		.max = 0xFFFF,
+		.step = 0x100,
+		.def = 0x0, // 0: sRGB
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_CONTRAST,
+		.name = "Contrast",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0x0,
+		.max = 0xFFFF,
+		.step = 0x100,
+		.def = 0x100,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_BRIGHTNESS,
+		.name = "Brightness",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0x0,
+		.max = 0xFFFF,
+		.step = 0x100,
+		.def = 0x100,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_SATURATION,
+		.name = "Saturation",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0x0,
+		.max = 0xFFFF,
+		.step = 0x100,
+		.def = 0x1000,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0x0,
+		.max = 0xC,
+		.step = 1,
+		.def = 0xC,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_EXPOSURE_METERING,
+		.name = "Exposure Metering",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0x0,
+		.max = 0x3,
+		.step = 1,
+		.def = 0x1,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0x0,
+		.max = 0xFFFF,
+		.step = 0x100,
+		.def = 0x100,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_HFLIP,
+		.name = "HFlip",
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_VFLIP,
+		.name = "VFlip",
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_ZOOM_ABSOLUTE,
+		.min = 0x0,
+		.max = 0x1000,
+		.step = 1,
+		.def = 0x0100,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_COLORFX,
+		.min = 0,
+		.max = 15,
+		.def = 0,
+		.menu_skip_mask = BIT(15) | BIT(12) | BIT(11) | BIT(10) | BIT(9),
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_SCENE_MODE,
+		.min = 0,
+		.max = 13,
+		.def = 0,
+		.menu_skip_mask = BIT(5) | BIT(4),
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_POWER_LINE_FREQUENCY,
+		.min = 0,
+		.max = 3,
+		.def = 3,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_FOCUS_AUTO,
+		.name = "Auto Focus",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
+	}, {
+		.ops = &ap1302_ctrl_ops,
+		.id = V4L2_CID_AP1302_STEREO_ORDER,
+		.name = "Stereo Order",
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
+	},
+};
+
+static int ap1302_ctrls_init(struct ap1302_device *ap1302)
+{
+	struct v4l2_ctrl *ctrl;
+	unsigned int i;
+	s64 *link_freq;
+	int ret;
+
+	ret = v4l2_ctrl_handler_init(&ap1302->ctrls, ARRAY_SIZE(ap1302_ctrls) + 1);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(ap1302_ctrls); i++) {
+		ctrl = v4l2_ctrl_new_custom(&ap1302->ctrls, &ap1302_ctrls[i], NULL);
+		ret = ap1302_g_ctrl(ctrl);
+		if (!ret && ctrl->default_value != ctrl->val) {
+			// Updating default value based on firmware values
+			dev_dbg(ap1302->dev, "Ctrl '%s' default value updated from %lld to %d\n",
+				ctrl->name, ctrl->default_value, ctrl->val);
+			ctrl->default_value = ctrl->val;
+			ctrl->cur.val = ctrl->val;
+		}
+	}
+
+	link_freq = devm_kzalloc(ap1302->dev, sizeof(link_freq), GFP_KERNEL);
+	*link_freq = *ap1302->bus_cfg.link_frequencies / 2;
+	//FIXME: /ap1302->bus_cfg.bus.mipi_csi2.num_data_lanes;
+	ctrl = v4l2_ctrl_new_int_menu(&ap1302->ctrls, &ap1302_ctrl_ops,
+				 V4L2_CID_LINK_FREQ, 0, 0, link_freq);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	if (ap1302->ctrls.error) {
+		ret = ap1302->ctrls.error;
+		v4l2_ctrl_handler_free(&ap1302->ctrls);
+		return ret;
+	}
+
+	/* Use same lock for controls as for everything else. */
+	ap1302->ctrls.lock = &ap1302->lock;
+	ap1302->sd.ctrl_handler = &ap1302->ctrls;
+
+	return 0;
+}
+
+static void ap1302_ctrls_cleanup(struct ap1302_device *ap1302)
+{
+	v4l2_ctrl_handler_free(&ap1302->ctrls);
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdev Operations
+ */
+
+static struct v4l2_mbus_framefmt *
+ap1302_get_pad_format(struct ap1302_device *ap1302,
+		      struct v4l2_subdev_state *sd_state,
+		      unsigned int pad, u32 which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(&ap1302->sd, sd_state, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &ap1302->formats[pad].format;
+	default:
+		return NULL;
+	}
+}
+
+static int ap1302_init_cfg(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_state *sd_state)
+{
+	u32 which = sd_state ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+	const struct ap1302_sensor_info *info = &ap1302->sensor_info;
+	unsigned int pad;
+
+	for (pad = 0; pad < ARRAY_SIZE(ap1302->formats); ++pad) {
+		struct v4l2_mbus_framefmt *format =
+			ap1302_get_pad_format(ap1302, sd_state, pad, which);
+
+		format->width = info->resolution.width;
+		format->height = info->resolution.height;
+
+		/*
+		 * The source pad combines images side by side in multi-sensor
+		 * setup.
+		 */
+		if (pad >= AP1302_PAD_SOURCE_VC0) {
+			format->width *= ap1302_width_factor(ap1302);
+			format->code = ap1302->formats[pad].info->code;
+		} else {
+			format->code = info->format;
+		}
+
+		format->field = V4L2_FIELD_NONE;
+		format->colorspace = V4L2_COLORSPACE_SRGB;
+	}
+
+	return 0;
+}
+
+static int ap1302_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+
+	if (code->pad < AP1302_PAD_SOURCE_VC0) {
+		/*
+		 * On the sink pads, only the format produced by the sensor is
+		 * supported.
+		 */
+		if (code->index)
+			return -EINVAL;
+
+		code->code = ap1302->sensor_info.format;
+	} else {
+		/* On the source pad, multiple formats are supported. */
+		if (code->index >= ARRAY_SIZE(supported_video_formats))
+			return -EINVAL;
+
+		code->code = supported_video_formats[code->index].code;
+	}
+
+	return 0;
+}
+
+static int ap1302_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+	unsigned int i;
+
+	if (fse->index)
+		return -EINVAL;
+
+	if (fse->pad < AP1302_PAD_SOURCE_VC0) {
+		/*
+		 * On the sink pads, only the size produced by the sensor is
+		 * supported.
+		 */
+		if (fse->code != ap1302->sensor_info.format)
+			return -EINVAL;
+
+		fse->min_width = ap1302->sensor_info.resolution.width;
+		fse->min_height = ap1302->sensor_info.resolution.height;
+		fse->max_width = ap1302->sensor_info.resolution.width;
+		fse->max_height = ap1302->sensor_info.resolution.height;
+	} else {
+		/*
+		 * On the source pad, the AP1302 can freely scale within the
+		 * scaler's limits.
+		 */
+		for (i = 0; i < ARRAY_SIZE(supported_video_formats); i++)
+			if (supported_video_formats[i].code == fse->code)
+				break;
+
+		if (i >= ARRAY_SIZE(supported_video_formats))
+			return -EINVAL;
+
+		fse->min_width = AP1302_MIN_WIDTH * ap1302_width_factor(ap1302);
+		fse->min_height = AP1302_MIN_HEIGHT;
+		fse->max_width = AP1302_MAX_WIDTH;
+		fse->max_height = AP1302_MAX_HEIGHT;
+	}
+
+	return 0;
+}
+
+static int ap1302_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+	const struct v4l2_mbus_framefmt *format;
+
+	format = ap1302_get_pad_format(ap1302, sd_state, fmt->pad, fmt->which);
+
+	mutex_lock(&ap1302->lock);
+	fmt->format = *format;
+	mutex_unlock(&ap1302->lock);
+
+	return 0;
+}
+
+static int ap1302_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+	const struct ap1302_format_info *info = NULL;
+	struct v4l2_mbus_framefmt *format;
+	unsigned int i;
+	u16 width_factor;
+
+	/* Formats on the sink pads can't be changed. */
+	if (fmt->pad < AP1302_PAD_SOURCE_VC0)
+		return ap1302_get_fmt(sd, sd_state, fmt);
+
+	format = ap1302_get_pad_format(ap1302, sd_state, fmt->pad, fmt->which);
+
+	/* Validate the media bus code, default to the first supported value. */
+	for (i = 0; i < ARRAY_SIZE(supported_video_formats); i++) {
+		if (supported_video_formats[i].code == fmt->format.code) {
+			info = &supported_video_formats[i];
+			break;
+		}
+	}
+
+	if (!info)
+		info = &supported_video_formats[0];
+
+
+	width_factor = ap1302_width_factor(ap1302);
+	/*
+	 * Clamp the size. The width must be a multiple of 4 (or 8 in the
+	 * dual-sensor case) and the height a multiple of 2.
+	 */
+	fmt->format.width = clamp(ALIGN_DOWN(fmt->format.width,
+					     4 * width_factor),
+				  AP1302_MIN_WIDTH * width_factor,
+				  AP1302_MAX_WIDTH);
+	fmt->format.height = clamp(ALIGN_DOWN(fmt->format.height, 2),
+				   AP1302_MIN_HEIGHT, AP1302_MAX_HEIGHT);
+
+	mutex_lock(&ap1302->lock);
+
+	format->width = fmt->format.width;
+	format->height = fmt->format.height;
+	format->code = info->code;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		ap1302->formats[fmt->pad].info = info;
+
+	mutex_unlock(&ap1302->lock);
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int ap1302_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_selection *sel)
+{
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+	const struct ap1302_size *resolution = &ap1302->sensor_info.resolution;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_NATIVE_SIZE:
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+	case V4L2_SEL_TGT_CROP:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = resolution->width * ap1302_width_factor(ap1302);
+		sel->r.height = resolution->height;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ap1302_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+	int ret;
+
+	mutex_lock(&ap1302->lock);
+
+	if (enable == ap1302->streaming)
+		goto done;
+
+	if (enable) {
+		ret = ap1302_configure(ap1302);
+		if (ret < 0)
+			goto done;
+
+		ret = ap1302_stall(ap1302, false);
+	} else {
+		ret = ap1302_stall(ap1302, true);
+	}
+
+done:
+	mutex_unlock(&ap1302->lock);
+
+	if (ret < 0)
+		dev_err(ap1302->dev, "Failed to %s stream: %d\n",
+			enable ? "start" : "stop", ret);
+
+	return ret;
+}
+
+static const char * const ap1302_warnings[] = {
+	"HINF_BANDWIDTH",
+	"FLICKER_DETECTION",
+	"FACED_NE",
+	"SMILED_NE",
+	"HINF_OVERRUN",
+	NULL,
+	"FRAME_TOO_SMALL",
+	"MISSING_PHASES",
+	"SPOOF_UNDERRUN",
+	"JPEG_NOLAST",
+	"NO_IN_FREQ_SPEC",
+	"SINF0",
+	"SINF1",
+	"CAPTURE0",
+	"CAPTURE1",
+	"ISR_UNHANDLED",
+	"INTERLEAVE_SPOOF",
+	"INTERLEAVE_BUF",
+	"COORD_OUT_OF_RANGE",
+	"ICP_CLOCKING",
+	"SENSOR_CLOCKING",
+	"SENSOR_NO_IHDR",
+	"DIVIDE_BY_ZERO",
+	"INT0_UNDERRUN",
+	"INT1_UNDERRUN",
+	"SCRATCHPAD_TOO_BIG",
+	"OTP_RECORD_READ",
+	"NO_LSC_IN_OTP",
+	"GPIO_INT_LOST",
+	"NO_PDAF_DATA",
+	"FAR_PDAF_ACCESS_SKIP",
+	"PDAF_ERROR",
+	"ATM_TVI_BOUNDS",
+	"SIPM_0_RTY",
+	"SIPM_1_TRY",
+	"SIPM_0_NO_ACK",
+	"SIPM_1_NO_ACK",
+	"SMILE_DIS",
+	"DVS_DIS",
+	"TEST_DIS",
+	"SENSOR_LV2LV",
+	"SENSOR_FV2FV",
+	"FRAME_LOST",
+};
+
+static const char * const ap1302_lane_states[] = {
+	"stop_s",
+	"hs_req_s",
+	"lp_req_s",
+	"hs_s",
+	"lp_s",
+	"esc_req_s",
+	"turn_req_s",
+	"esc_s",
+	"esc_0",
+	"esc_1",
+	"turn_s",
+	"turn_mark",
+	"error_s",
+};
+
+static int ap1302_log_status(struct v4l2_subdev *sd)
+{
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+	u16 frame_count_icp;
+	u16 frame_count_brac;
+	u16 frame_count_hinf;
+	u32 warning[4];
+	u32 error[3];
+	unsigned int i;
+	u32 value;
+	int ret;
+
+	/* Dump the console buffer. */
+	ap1302_dump_console(ap1302);
+
+
+	/* Print errors. */
+	ret = ap1302_read(ap1302, AP1302_ERROR, &error[0]);
+	if (ret < 0)
+		return ret;
+
+	ret = ap1302_read(ap1302, AP1302_ERR_FILE, &error[1]);
+	if (ret < 0)
+		return ret;
+
+	ret = ap1302_read(ap1302, AP1302_ERR_LINE, &error[2]);
+	if (ret < 0)
+		return ret;
+
+	dev_info(ap1302->dev, "ERROR: 0x%04x (file 0x%08x:%u)\n",
+		 error[0], error[1], error[2]);
+
+	ret = ap1302_read(ap1302, AP1302_SIPM_ERR_0, &error[0]);
+	if (ret < 0)
+		return ret;
+
+	ret = ap1302_read(ap1302, AP1302_SIPM_ERR_1, &error[1]);
+	if (ret < 0)
+		return ret;
+
+	dev_info(ap1302->dev, "SIPM_ERR [0] 0x%04x [1] 0x%04x\n",
+		 error[0], error[1]);
+
+	/* Print warnings. */
+	for (i = 0; i < ARRAY_SIZE(warning); ++i) {
+		ret = ap1302_read(ap1302, AP1302_WARNING(i), &warning[i]);
+		if (ret < 0)
+			return ret;
+	}
+
+	dev_info(ap1302->dev,
+		 "WARNING [0] 0x%04x [1] 0x%04x [2] 0x%04x [3] 0x%04x\n",
+		 warning[0], warning[1], warning[2], warning[3]);
+
+	for (i = 0; i < ARRAY_SIZE(ap1302_warnings); ++i)
+		if ((warning[i / 16] & BIT(i % 16)) && ap1302_warnings[i])
+			dev_info(ap1302->dev, "- WARN_%s\n", ap1302_warnings[i]);
+
+	/* Print the frame counter. */
+	ret = ap1302_read(ap1302, AP1302_FRAME_CNT, &value);
+	if (ret < 0)
+		return ret;
+
+	frame_count_hinf = value >> 8;
+	frame_count_brac = value & 0xff;
+
+	ret = ap1302_read(ap1302, AP1302_ADV_CAPTURE_A_FV_CNT, &value);
+	if (ret < 0)
+		return ret;
+
+	frame_count_icp = value & 0xffff;
+
+	dev_info(ap1302->dev, "Frame counters: ICP %u, HINF %u, BRAC %u\n",
+		 frame_count_icp, frame_count_hinf, frame_count_brac);
+
+	/* Provide Autofocus Info */
+	ret = ap1302_read(ap1302, AP1302_AF_CTRL, &value);
+	if (ret < 0)
+		return ret;
+	if ((value & AP1302_AF_CTRL_MODE_MASK) == AP1302_AF_CTRL_MODE_AUTO) {
+		ret = ap1302_read(ap1302, AP1302_AF_POS, &value);
+		if (ret < 0)
+			return ret;
+		dev_info(ap1302->dev, "AF Pos: %d\n", (s16)value);
+	}
+
+	return 0;
+}
+
+static int ap1302_subdev_registered(struct v4l2_subdev *sd)
+{
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+	unsigned int i;
+	const char *status;
+	int ret;
+	u32 flag;
+
+	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
+		struct ap1302_sensor *sensor = &ap1302->sensors[i];
+
+		dev_dbg(ap1302->dev, "registering sensor %u\n", i);
+
+		ret = v4l2_device_register_subdev(sd->v4l2_dev, &sensor->sd);
+		if (ret)
+			return ret;
+
+		flag = 0;
+		status = of_get_property(sensor->of_node, "status", &ret);
+		if (status == NULL) {
+			// No sensor node, unconnected, disabled
+			flag = MEDIA_LNK_FL_IMMUTABLE;
+		} else if (ret > 0) {
+			if (!strcmp(status, "okay") || !strcmp(status, "ok"))
+				flag = MEDIA_LNK_FL_ENABLED;
+			else if (!strcmp(status, "immutable"))
+				flag = MEDIA_LNK_FL_ENABLED |
+					MEDIA_LNK_FL_IMMUTABLE;
+			// else disabled
+		}
+
+		ret = media_create_pad_link(&sensor->sd.entity, 0,
+					    &sd->entity, i,
+					    flag);
+		if (ret)
+			return ret;
+
+		/* Notify MIPI subdev entity */
+		ret = media_entity_call(&sd->entity, link_setup,
+					&sd->entity.pads[i],
+					&sensor->sd.entity.pads[0],
+					flag);
+		if (ret < 0 && ret != -ENOIOCTLCMD)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* mipi csi2 subdev media entity operations */
+static int ap1302_link_setup(struct media_entity *entity,
+			     const struct media_pad *local,
+			     const struct media_pad *remote, u32 flags)
+{
+	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+
+	dev_dbg(ap1302->dev, "%s <-> %s\n",
+		local->entity->name, remote->entity->name);
+	dev_dbg(ap1302->dev, "%s flags %lx index %d : %d\n", __func__,
+		local->flags, local->index, flags);
+
+	if (local->flags & MEDIA_PAD_FL_SOURCE) {
+		switch (local->index) {
+		case AP1302_PAD_SOURCE_VC0:
+		case AP1302_PAD_SOURCE_VC2:
+		case AP1302_PAD_SOURCE_VC3:
+			// VC0 is the default
+			// VC2 and VC3 would need support for VC selection
+			break;
+		case AP1302_PAD_SOURCE_VC1:
+			ap1302->use_vcid = flags & MEDIA_LNK_FL_ENABLED ? 1 : 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+	} else if (local->flags & MEDIA_PAD_FL_SINK) {
+		switch (local->index) {
+		case AP1302_PAD_SINK_0:
+		case AP1302_PAD_SINK_1:
+			ap1302->sensors[local->index].link_enabled = !!(flags & MEDIA_LNK_FL_ENABLED);
+			dev_info(ap1302->dev, "Sensor %d Link %s\n", local->index,
+				flags & MEDIA_LNK_FL_ENABLED ? "Enabled" : "Disabled");
+
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static const struct media_entity_operations ap1302_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+	.link_setup = ap1302_link_setup
+};
+
+static const struct v4l2_subdev_pad_ops ap1302_pad_ops = {
+	.init_cfg = ap1302_init_cfg,
+	.enum_mbus_code = ap1302_enum_mbus_code,
+	.enum_frame_size = ap1302_enum_frame_size,
+	.get_fmt = ap1302_get_fmt,
+	.set_fmt = ap1302_set_fmt,
+	.get_selection = ap1302_get_selection,
+	.set_selection = ap1302_get_selection,
+};
+
+static const struct v4l2_subdev_video_ops ap1302_video_ops = {
+	.s_stream = ap1302_s_stream,
+};
+
+static const struct v4l2_subdev_core_ops ap1302_core_ops = {
+	.log_status = ap1302_log_status,
+};
+
+static const struct v4l2_subdev_ops ap1302_subdev_ops = {
+	.core = &ap1302_core_ops,
+	.video = &ap1302_video_ops,
+	.pad = &ap1302_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops ap1302_subdev_internal_ops = {
+	.registered = ap1302_subdev_registered,
+};
+
+/* -----------------------------------------------------------------------------
+ * Sensor
+ */
+
+static int ap1302_sensor_enum_mbus_code(struct v4l2_subdev *sd,
+					struct v4l2_subdev_state *sd_state,
+					struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct ap1302_sensor *sensor = to_ap1302_sensor(sd);
+	const struct ap1302_sensor_info *info = &sensor->ap1302->sensor_info;
+
+	if (code->index)
+		return -EINVAL;
+
+	code->code = info->format;
+	return 0;
+}
+
+static int ap1302_sensor_enum_frame_size(struct v4l2_subdev *sd,
+					 struct v4l2_subdev_state *sd_state,
+					 struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ap1302_sensor *sensor = to_ap1302_sensor(sd);
+	const struct ap1302_sensor_info *info = &sensor->ap1302->sensor_info;
+
+	if (fse->index)
+		return -EINVAL;
+
+	if (fse->code != info->format)
+		return -EINVAL;
+
+	fse->min_width = info->resolution.width;
+	fse->min_height = info->resolution.height;
+	fse->max_width = info->resolution.width;
+	fse->max_height = info->resolution.height;
+
+	return 0;
+}
+
+static int ap1302_sensor_get_fmt(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct ap1302_sensor *sensor = to_ap1302_sensor(sd);
+	const struct ap1302_sensor_info *info = &sensor->ap1302->sensor_info;
+
+	memset(&fmt->format, 0, sizeof(fmt->format));
+
+	fmt->format.width = info->resolution.width;
+	fmt->format.height = info->resolution.height;
+	fmt->format.field = V4L2_FIELD_NONE;
+	fmt->format.code = info->format;
+	fmt->format.colorspace = V4L2_COLORSPACE_SRGB;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops ap1302_sensor_pad_ops = {
+	.enum_mbus_code = ap1302_sensor_enum_mbus_code,
+	.enum_frame_size = ap1302_sensor_enum_frame_size,
+	.get_fmt = ap1302_sensor_get_fmt,
+	.set_fmt = ap1302_sensor_get_fmt,
+};
+
+static const struct v4l2_subdev_ops ap1302_sensor_subdev_ops = {
+	.pad = &ap1302_sensor_pad_ops,
+};
+
+static int ap1302_sensor_parse_of(struct ap1302_device *ap1302,
+				  struct device_node *node)
+{
+	struct ap1302_sensor *sensor;
+	u32 reg;
+	int ret;
+	int num_supplies;
+	struct property *prop;
+	const char *supply;
+	u32 delay;
+	const __be32 *p;
+	int count;
+
+	/* Retrieve the sensor index from the reg property. */
+	ret = of_property_read_u32(node, "reg", &reg);
+	if (ret < 0) {
+		dev_warn(ap1302->dev, "'reg' property missing in sensor node\n");
+		return -EINVAL;
+	}
+
+	if (reg >= ARRAY_SIZE(ap1302->sensors)) {
+		dev_warn(ap1302->dev, "Out-of-bounds 'reg' value %u\n", reg);
+		return -EINVAL;
+	}
+
+	sensor = &ap1302->sensors[reg];
+	if (sensor->ap1302) {
+		dev_warn(ap1302->dev, "Duplicate entry for sensor %u\n", reg);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "sip", &sensor->sip);
+	if (ret) {
+		dev_warn(ap1302->dev,
+			 "Sensor %d: error reading sip property %d\n", reg, ret);
+	}
+
+	num_supplies = of_property_count_strings(node, "regulator-supplies");
+	if (num_supplies < 0) {
+		if (num_supplies != -EINVAL)
+			dev_warn(ap1302->dev,
+				 "sensor %d: no regulators defined\n", reg);
+		num_supplies = 0;
+	}
+
+	if (num_supplies) {
+		sensor->num_supplies = num_supplies;
+
+		sensor->supplies_data = devm_kzalloc(ap1302->dev, num_supplies *
+					sizeof(*sensor->supplies_data), GFP_KERNEL);
+		if (!sensor->supplies_data)
+			return -ENOMEM;
+
+		count = 0;
+		of_property_for_each_string(node, "regulator-supplies", prop, supply)
+			sensor->supplies_data[count++].name = supply;
+
+		count = 0;
+		of_property_for_each_u32(node, "regulator-delays", prop, p, delay)
+			sensor->supplies_data[count++].post_delay_us = delay;
+	}
+
+	sensor->of_node = of_node_get(node);
+
+	return 0;
+}
+
+static void ap1302_sensor_dev_release(struct device *dev)
+{
+	of_node_put(dev->of_node);
+	kfree(dev);
+}
+
+static int ap1302_sensor_init(struct ap1302_sensor *sensor, unsigned int index)
+{
+	struct ap1302_device *ap1302 = sensor->ap1302;
+	struct v4l2_subdev *sd = &sensor->sd;
+	unsigned int i;
+	int ret;
+
+	sensor->index = index;
+
+	/*
+	 * Register a device for the sensor, to support usage of the regulator
+	 * API.
+	 */
+	sensor->dev = kzalloc(sizeof(*sensor->dev), GFP_KERNEL);
+	if (!sensor->dev)
+		return -ENOMEM;
+
+	sensor->dev->parent = ap1302->dev;
+	sensor->dev->of_node = of_node_get(sensor->of_node);
+	sensor->dev->release = &ap1302_sensor_dev_release;
+	dev_set_name(sensor->dev, "%s-%s.%u", dev_name(ap1302->dev),
+		     ap1302->sensor_info.model, index);
+
+	ret = device_register(sensor->dev);
+	if (ret < 0) {
+		dev_err(ap1302->dev,
+			"Failed to register device for sensor %u\n", index);
+		goto error;
+	}
+
+	/* Retrieve the power supplies for the sensor, if any. */
+	if (sensor->num_supplies) {
+		const struct ap1302_sensor_supply *supplies =
+				sensor->supplies_data;
+
+		sensor->supplies = devm_kcalloc(ap1302->dev, sensor->num_supplies,
+						sizeof(*sensor->supplies),
+						GFP_KERNEL);
+		if (!sensor->supplies) {
+			ret = -ENOMEM;
+			goto error;
+		}
+
+		for (i = 0; i < sensor->num_supplies; ++i)
+			sensor->supplies[i].supply = supplies[i].name;
+
+		ret = regulator_bulk_get(sensor->dev, sensor->num_supplies,
+					 sensor->supplies);
+		if (ret < 0) {
+			dev_err(ap1302->dev,
+				"Failed to get supplies for sensor %u\n", index);
+			goto error;
+		}
+	}
+
+	sd->dev = sensor->dev;
+	v4l2_subdev_init(sd, &ap1302_sensor_subdev_ops);
+
+	snprintf(sd->name, sizeof(sd->name), "%s.%s.%u",
+			dev_name(ap1302->dev), ap1302->sensor_info.model, index);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_pads_init(&sd->entity, 1, &sensor->pad);
+	if (ret < 0) {
+		dev_err(ap1302->dev,
+			"failed to initialize media entity for sensor %u: %d\n",
+			index, ret);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	put_device(sensor->dev);
+	return ret;
+}
+
+static void ap1302_sensor_cleanup(struct ap1302_sensor *sensor)
+{
+	media_entity_cleanup(&sensor->sd.entity);
+
+	if (sensor->num_supplies)
+		regulator_bulk_free(sensor->num_supplies, sensor->supplies);
+
+	device_unregister(sensor->dev);
+	of_node_put(sensor->of_node);
+}
+
+/* --------------------------------------------------------------------------
+ * sysfs attributes
+ */
+static ssize_t stall_standby_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+
+	if (strtobool(buf, &ap1302->stall_standby) < 0)
+		return -EINVAL;
+
+	return size;
+}
+
+static ssize_t stall_standby_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+
+	return sysfs_emit(buf, "%d\n", ap1302->stall_standby);
+}
+
+static DEVICE_ATTR(stall_standby, 0644, stall_standby_show, stall_standby_store);
+
+static ssize_t lane_status_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+	static const char * const lp_states[] = {
+		"00", "10", "01", "11",
+	};
+	unsigned int index;
+	unsigned int counts[4][ARRAY_SIZE(ap1302_lane_states)];
+	unsigned int samples = 0;
+	unsigned int lane;
+	unsigned int i;
+	u32 first[4] = { 0, };
+	u32 last[4] = { 0, };
+	int ret;
+	u32 buf_len = 0;
+
+	/* Sample the lane state. */
+	for (index = 0; index < ARRAY_SIZE(ap1302->sensors); ++index) {
+		struct ap1302_sensor *sensor = &ap1302->sensors[index];
+
+		if (!sensor->ap1302)
+			continue;
+
+		samples = 0;
+		memset(first, 0, sizeof(first));
+		memset(last, 0, sizeof(last));
+		memset(counts, 0, sizeof(counts));
+
+		for (i = 0; i < 1000; ++i) {
+			u32 values[4];
+
+			/*
+			 * Read the state of all lanes and skip read errors and invalid
+			 * values.
+			 */
+			for (lane = 0; lane < 4; ++lane) {
+				ret = ap1302_read(sensor->ap1302,
+						  AP1302_ADV_SINF_MIPI_INTERNAL_p_LANE_n_STAT(index, lane),
+						  &values[lane]);
+				if (ret < 0)
+					break;
+
+				if (AP1302_LANE_STATE(values[lane]) >=
+				    ARRAY_SIZE(ap1302_lane_states)) {
+					ret = -EINVAL;
+					break;
+				}
+			}
+
+			if (ret < 0)
+				continue;
+
+			/* Accumulate the samples and save the first and last states. */
+			for (lane = 0; lane < 4; ++lane)
+				counts[lane][AP1302_LANE_STATE(values[lane])]++;
+
+			if (!samples)
+				memcpy(first, values, sizeof(first));
+			memcpy(last, values, sizeof(last));
+
+			samples++;
+		}
+
+		if (!samples)
+			return buf_len;
+
+		/*
+		 * Print the LP state from the first sample, the error state from the
+		 * last sample, and the states accumulators for each lane.
+		 */
+		for (lane = 0; lane < 4; ++lane) {
+			u32 state = last[lane];
+			char error_msg[25] = "";
+
+			if (state & (AP1302_LANE_ERR | AP1302_LANE_ABORT)) {
+				unsigned int err = AP1302_LANE_ERR_STATE(state);
+				const char *err_state;
+
+				err_state = err < ARRAY_SIZE(ap1302_lane_states)
+					  ? ap1302_lane_states[err] : "INVALID";
+
+				scnprintf(error_msg, sizeof(error_msg), "ERR (%s%s) %s LP%s",
+					 state & AP1302_LANE_ERR ? "E" : "",
+					 state & AP1302_LANE_ABORT ? "A" : "",
+					 err_state,
+					 lp_states[AP1302_LANE_ERR_LP_VAL(state)]);
+			}
+			buf_len += scnprintf(buf+buf_len, PAGE_SIZE - buf_len,
+					"SINF%u L%u state: LP%s %s\n",
+					 index, lane,
+					 lp_states[AP1302_LANE_LP_VAL(first[lane])],
+					 error_msg);
+
+			for (i = 0; i < ARRAY_SIZE(ap1302_lane_states); ++i) {
+				if (counts[lane][i])
+					buf_len += scnprintf(buf + buf_len,
+						PAGE_SIZE - buf_len, " %s:%u",
+						ap1302_lane_states[i],
+						counts[lane][i]);
+			}
+			buf_len += scnprintf(buf + buf_len, PAGE_SIZE-buf_len, "\n");
+		}
+	}
+
+	return buf_len;
+}
+
+static DEVICE_ATTR(lane_status, 0444, lane_status_show, NULL);
+
+/* -----------------------------------------------------------------------------
+ * Boot & Firmware Handling
+ */
+
+struct header_ver2 {
+	u8 header_version;
+	u16 content_offset;
+	u8 product_name[64];
+	u8 product_version;
+	u8 lens_name[64];
+	u8 lens_version;
+	u8 content_version;
+	u32 content_checksum;
+	u32 content_len;
+	u16 pll_bootdata_len;
+} __packed;
+
+struct header_ver3 {
+	u8 header_version;
+	u16 content_offset;
+	u16 sensor_type;
+	u8 sensor_fuseid[16];
+	u8 product_name[64];
+	u8 lens_id[16];
+	u16 fix_checksum;
+	u8 tn_fw_version[2];
+	u16 vendor_fw_version;
+	u16 custom_number;
+	u8 build_year;
+	u8 build_month;
+	u8 build_day;
+	u8 build_hour;
+	u8 build_minute;
+	u8 build_second;
+	u16 mipi_datarate;
+	u32 content_len;
+	u16 content_checksum;
+	u16 total_checksum;
+} __packed;
+
+static int ap1302_request_firmware_nvmem(struct ap1302_device *ap1302)
+{
+	u8 version;
+
+	dev_info(ap1302->dev, "Loading firmware from NVMEM\n");
+
+	nvmem_device_read(ap1302->nvmem, 0, sizeof(version), &version);
+
+	if (version == 2) {
+		struct header_ver2 header2;
+
+		nvmem_device_read(ap1302->nvmem, 0, sizeof(header2), &header2);
+
+		dev_info(ap1302->dev, "Product:%s, Version:%d. Lens:%s, Version:%d\n",
+			 header2.product_name,
+			 header2.product_version,
+			 header2.lens_name,
+			 header2.lens_version);
+
+		ap1302->fw_size = header2.content_len;
+		ap1302->fw_data = devm_kzalloc(ap1302->dev, ap1302->fw_size, GFP_KERNEL);
+		if (!ap1302->fw_data)
+			return -ENOMEM;
+
+		nvmem_device_read(ap1302->nvmem, header2.content_offset,
+				  ap1302->fw_size, ap1302->fw_data);
+
+		return 0;
+	} else if (version == 3) {
+		struct header_ver3 header3;
+
+		nvmem_device_read(ap1302->nvmem, 0, sizeof(header3), &header3);
+
+		dev_info(ap1302->dev, "Product:%s, HeaderVer:%d, Version:%d.%d.%d.%d, MIPI_Rate:%d\n",
+			 header3.product_name,
+			 header3.header_version,
+			 header3.tn_fw_version[0],
+			 header3.tn_fw_version[1],
+			 header3.vendor_fw_version,
+			 header3.custom_number,
+			 header3.mipi_datarate);
+
+		ap1302->fw_size = header3.content_len;
+		ap1302->fw_data = devm_kzalloc(ap1302->dev, ap1302->fw_size, GFP_KERNEL);
+		if (!ap1302->fw_data)
+			return -ENOMEM;
+
+		nvmem_device_read(ap1302->nvmem, header3.content_offset,
+				  ap1302->fw_size, ap1302->fw_data);
+
+		return 0;
+	}
+
+	dev_err(ap1302->dev, "can't recognize header version number '0x%X'\n",
+		version);
+
+	return -EINVAL;
+}
+
+static int ap1302_request_firmware_file(struct ap1302_device *ap1302)
+{
+	const struct ap1302_firmware_header *fw_hdr;
+	char name[64];
+	int ret;
+
+	ret = snprintf(name, sizeof(name), "ap1302_%s_fw.bin",
+			ap1302->sensor_info.model);
+	if (ret >= sizeof(name)) {
+		dev_err(ap1302->dev, "Firmware name too long\n");
+		return -EINVAL;
+	}
+
+	if (fw_name_param != NULL) {
+		ret = snprintf(name, sizeof(name), "%s", fw_name_param);
+		if (ret >= sizeof(name)) {
+			dev_err(ap1302->dev, "Firmware name too long\n");
+			return -EINVAL;
+		}
+	}
+
+	dev_info(ap1302->dev, "Requesting firmware %s\n", name);
+
+	ret = request_firmware(&ap1302->fw, name, ap1302->dev);
+	if (ret) {
+		dev_err(ap1302->dev, "Failed to request firmware: %d\n", ret);
+		return ret;
+	}
+
+	fw_hdr = (const struct ap1302_firmware_header *)ap1302->fw->data;
+
+	/*
+	 * The firmware binary contains a header defined by the
+	 * ap1302_firmware_header structure. The firmware itself (also referred
+	 * to as bootdata) follows the header. Perform sanity checks to ensure
+	 * the firmware is valid.
+	 */
+	if (fw_hdr->magic == FW_MAGIC) {
+		dev_info(ap1302->dev, "Firmware header version : %d\n",
+			 fw_hdr->version);
+		dev_info(ap1302->dev, "Firmware description : %s\n",
+			 fw_hdr->desc);
+
+		ap1302->fw_size = ap1302->fw->size - sizeof(*fw_hdr);
+
+		if (fw_hdr->pll_init_size > ap1302->fw_size) {
+			dev_err(ap1302->dev,
+				"Invalid firmware: PLL init size too large\n");
+			return -EINVAL;
+		}
+
+		ap1302->fw_data = (u8 *)&fw_hdr[1];
+	} else {
+		dev_warn(ap1302->dev,
+			 "Invalid firmware header detected; Assuming Raw Binary\n");
+		ap1302->fw_data = (u8 *)ap1302->fw->data;
+		ap1302->fw_size = ap1302->fw->size;
+	}
+
+	return 0;
+}
+
+static int ap1302_request_firmware(struct ap1302_device *ap1302)
+{
+	if (ap1302->nvmem)
+		return ap1302_request_firmware_nvmem(ap1302);
+
+	return ap1302_request_firmware_file(ap1302);
+}
+
+/*
+ * ap1302_write_fw_window() - Write a piece of firmware to the AP1302
+ *
+ * The firmware is loaded through a window in the registers space. Writes are
+ * sequential starting at address 0x8000, and must wrap around when reaching
+ * 0x9fff. This function write the firmware data stored in @buf to the AP1302,
+ * keeping track of the window position in the win_pos variable.
+ */
+static int ap1302_write_fw_window(struct ap1302_device *ap1302)
+{
+	const u8 *buf = ap1302->fw_data;
+	u32 len = ap1302->fw_size;
+	unsigned int win_pos = 0;
+
+	while (len > 0) {
+		unsigned int write_addr, write_size;
+		int ret;
+
+		/*
+		 * Write at most len bytes, from the current position to the
+		 * end of the window.
+		 */
+		write_addr = win_pos + AP1302_FW_WINDOW_OFFSET;
+		write_size = min(len, AP1302_FW_WINDOW_SIZE - win_pos);
+
+		ret = regmap_raw_write(ap1302->regmap16, write_addr, buf,
+				       write_size);
+		if (ret)
+			return ret;
+
+		buf += write_size;
+		len -= write_size;
+
+		win_pos += write_size;
+		if (win_pos >= AP1302_FW_WINDOW_SIZE)
+			win_pos = 0;
+	}
+
+	return 0;
+}
+
+static int ap1302_load_firmware(struct ap1302_device *ap1302)
+{
+	unsigned int value;
+	unsigned long clock_freq, clock_fp_mhz;
+	int i, ret;
+
+	// Fixed Point Calculation
+#define HZ_TO_S15_16_MHZ(hz) \
+	((s32)div_s64(((s64)(hz)) << 16, 1000000))
+
+	if (ap1302->clock) {
+		clock_freq = clk_get_rate(ap1302->clock);
+		clock_fp_mhz = HZ_TO_S15_16_MHZ(clock_freq);
+		dev_info(ap1302->dev, "AP1302 oscillator clock %ld hz (FP 0x%08lx)\n",
+			 clock_freq, clock_fp_mhz);
+
+		ret = ap1302_write(ap1302, AP1302_SYSTEM_FREQ_IN,
+				   clock_fp_mhz, NULL);
+		if (ret)
+			return ret;
+	}
+
+	// Using the first link frequency
+	clock_freq = (u32)*ap1302->bus_cfg.link_frequencies;
+	clock_fp_mhz = HZ_TO_S15_16_MHZ(clock_freq);
+	dev_info(ap1302->dev, "AP1302 MIPI frequency %ld hz (FP 0x%08lx)\n",
+		 clock_freq, clock_fp_mhz);
+
+	ret = ap1302_write(ap1302, AP1302_HINF_MIPI_FREQ_TGT,
+			clock_fp_mhz, NULL);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
+		ret = ap1302_read(ap1302, AP1302_SENSOR_SIP(i), &value);
+		if (ret < 0)
+			return ret;
+		dev_info(ap1302->dev, "Sensor %d SIP %04X\n", i, value);
+
+		if (ap1302->sensors[i].sip) {
+			ret = ap1302_write(ap1302, AP1302_SENSOR_SIP(i),
+					   ap1302->sensors[i].sip, NULL);
+			if (ret)
+				return ret;
+
+			dev_dbg(ap1302->dev, "Sensor %d SIP update %04X\n",
+				i, ap1302->sensors[i].sip);
+		}
+
+		ret = ap1302_read(ap1302, AP1302_SENSOR_SIP(i), &value);
+		if (ret < 0)
+			return ret;
+		dev_dbg(ap1302->dev, "Sensor %d Read SIP %04X\n", i, value);
+	}
+
+	/* Load bootdata, pll_init_size not needed for firmware 429 and later */
+	ret = ap1302_write_fw_window(ap1302);
+	if (ret)
+		return ret;
+
+	msleep(40);
+
+	/*
+	 * Write 0xffff to the bootdata_stage register to indicate to the
+	 * AP1302 that the whole bootdata content has been loaded.
+	 */
+	ret = ap1302_write(ap1302, AP1302_BOOTDATA_STAGE, 0xffff, NULL);
+	if (ret)
+		return ret;
+
+	msleep(10);
+
+	/*
+	 * Wait for AP1302_BOOTDATA_STAGE to become 0xffff
+	 */
+	ret = ap1302_poll_timeout(ap1302, AP1302_BOOTDATA_STAGE,
+				  value, value == 0xffff, 10000, 5000000);
+	if (ret < 0) {
+		dev_err(ap1302->dev,
+			"AP1302_BOOTDATA_STAGE not 0xffff : %04X (POLL %d)\n",
+			value, ret);
+		// Dump
+		ap1302_log_status(&ap1302->sd);
+#if defined(DEBUG)
+	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
+		ap1302_read(ap1302, AP1302_SENSOR_SIP(i), &value);
+		dev_dbg(ap1302->dev, "Sensor %d FIRMWARE LOADED SIP %04X\n",
+			i, value);
+
+	}
+#endif
+		return ret;
+	}
+
+	/* Print errors. */
+	ret = ap1302_read(ap1302, AP1302_ERROR, &value);
+	if (ret < 0)
+		return ret;
+
+	if (value) {
+		dev_warn(ap1302->dev, "Error Reg : %04X\n", value);
+		return -EAGAIN;
+	}
+
+#if defined(DEBUG)
+	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
+		ret = ap1302_read(ap1302, AP1302_SENSOR_SIP(i), &value);
+		if (ret < 0)
+			return ret;
+		dev_dbg(ap1302->dev, "Sensor %d FIRMWARE LOADED SIP %04X\n",
+			i, value);
+
+		if (ap1302->sensors[i].sip) {
+			ret = ap1302_write(ap1302, AP1302_SENSOR_SIP(i),
+					ap1302->sensors[i].sip, NULL);
+			if (ret)
+				return ret;
+
+			dev_dbg(ap1302->dev, "Sensor %d SIP update %04X\n",
+				i, ap1302->sensors[i].sip);
+		}
+	}
+#endif
+
+	/* The AP1302 starts outputting frames right after boot, stop it. */
+	ret = ap1302_stall(ap1302, true);
+	if (ret)
+		return ret;
+
+	/* Adjust MIPI TCLK timings */
+	return ap1302_set_mipi_t3_clk(ap1302);
+}
+
+static int ap1302_detect_chip(struct ap1302_device *ap1302)
+{
+	unsigned int version, revision;
+	int ret;
+
+	ret = ap1302_read(ap1302, AP1302_CHIP_VERSION, &version);
+	if (ret)
+		return ret;
+
+	ret = ap1302_read(ap1302, AP1302_CHIP_REV, &revision);
+	if (ret)
+		return ret;
+
+	if (version != AP1302_CHIP_ID) {
+		dev_err(ap1302->dev,
+			"Invalid chip version, expected 0x%04x, got 0x%04x\n",
+			AP1302_CHIP_ID, version);
+		return -EINVAL;
+	}
+
+	dev_info(ap1302->dev, "AP1302 revision %u.%u.%u detected\n",
+		 (revision & 0xf000) >> 12, (revision & 0x0f00) >> 8,
+		 revision & 0x00ff);
+
+	return 0;
+}
+
+static int ap1302_hw_init(struct ap1302_device *ap1302)
+{
+	unsigned int retries;
+	int ret;
+
+	/* Request and validate the firmware. */
+	ret = ap1302_request_firmware(ap1302);
+	if (ret)
+		return ret;
+
+	/*
+	 * Power the sensors first, as the firmware will access them once it
+	 * gets loaded.
+	 */
+	ret = ap1302_power_on_sensors(ap1302);
+	if (ret < 0)
+		goto error_firmware;
+
+	/*
+	 * Load the firmware, retrying in case of CRC errors. The AP1302 is
+	 * reset with a full power cycle between each attempt.
+	 */
+	for (retries = 0; retries < MAX_FW_LOAD_RETRIES; ++retries) {
+		ret = ap1302_power_on(ap1302);
+		if (ret < 0)
+			goto error_power_sensors;
+
+		ret = ap1302_detect_chip(ap1302);
+		if (ret)
+			goto error_power;
+
+		ret = ap1302_load_firmware(ap1302);
+		if (!ret)
+			break;
+
+		if (ret != -EAGAIN)
+			goto error_power;
+
+		// Dump
+		ap1302_log_status(&ap1302->sd);
+
+		ap1302_power_off(ap1302);
+	}
+
+	if (retries == MAX_FW_LOAD_RETRIES) {
+		dev_err(ap1302->dev,
+			"Firmware load retries exceeded, aborting\n");
+		ret = -ETIMEDOUT;
+		goto error_power_sensors;
+	}
+
+	return 0;
+
+error_power:
+	ap1302_power_off(ap1302);
+
+error_power_sensors:
+	ap1302_power_off_sensors(ap1302);
+
+error_firmware:
+	release_firmware(ap1302->fw);
+
+	return ret;
+}
+
+static void ap1302_hw_cleanup(struct ap1302_device *ap1302)
+{
+	ap1302_power_off(ap1302);
+	ap1302_power_off_sensors(ap1302);
+}
+
+/* -----------------------------------------------------------------------------
+ * Probe & Remove
+ */
+
+static int ap1302_config_v4l2(struct ap1302_device *ap1302)
+{
+	struct v4l2_subdev *sd;
+	unsigned int i;
+	int ret;
+
+	sd = &ap1302->sd;
+	sd->dev = ap1302->dev;
+	v4l2_i2c_subdev_init(sd, ap1302->client, &ap1302_subdev_ops);
+
+	strscpy(sd->name, DRIVER_NAME, sizeof(sd->name));
+	strlcat(sd->name, ".", sizeof(sd->name));
+	strlcat(sd->name, dev_name(ap1302->dev), sizeof(sd->name));
+	dev_dbg(ap1302->dev, "name %s\n", sd->name);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	sd->internal_ops = &ap1302_subdev_internal_ops;
+	// MEDIA_ENT_F_CAM_SENSOR : MEDIA_ENT_F_PROC_VIDEO_ISP not defined yet
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	sd->entity.ops = &ap1302_media_ops;
+
+	for (i = 0; i < ARRAY_SIZE(ap1302->pads); ++i)
+		ap1302->pads[i].flags = i >= AP1302_PAD_SOURCE_VC0
+				      ? MEDIA_PAD_FL_SOURCE : MEDIA_PAD_FL_SINK;
+
+	ret = media_entity_pads_init(&sd->entity, ARRAY_SIZE(ap1302->pads),
+				     ap1302->pads);
+	if (ret < 0) {
+		dev_err(ap1302->dev, "media_entity_init failed %d\n", ret);
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ap1302->formats); ++i)
+		ap1302->formats[i].info = &supported_video_formats[0];
+
+	ret = ap1302_init_cfg(sd, NULL);
+	if (ret < 0)
+		goto error_media;
+
+	ret = ap1302_ctrls_init(ap1302);
+	if (ret < 0)
+		goto error_media;
+
+	ret = v4l2_async_register_subdev(sd);
+	if (ret < 0) {
+		dev_err(ap1302->dev, "v4l2_async_register_subdev failed %d\n", ret);
+		goto error_ctrls;
+	}
+
+	return 0;
+
+error_ctrls:
+	ap1302_ctrls_cleanup(ap1302);
+
+error_media:
+	media_entity_cleanup(&sd->entity);
+	return ret;
+}
+
+static int ap1302_parse_of(struct ap1302_device *ap1302)
+{
+	struct device_node *sensors;
+	struct device_node *node;
+	struct fwnode_handle *ep;
+	int ret;
+
+	/* Clock */
+	ap1302->clock = devm_clk_get_optional(ap1302->dev, NULL);
+	if (IS_ERR(ap1302->clock)) {
+		ret = PTR_ERR(ap1302->clock);
+
+		dev_err(ap1302->dev, "Failed to get clock: %i\n", ret);
+
+		return ret;
+	}
+
+	/* GPIOs */
+	ap1302->reset_gpio = devm_gpiod_get(ap1302->dev, "reset",
+					    GPIOD_OUT_HIGH);
+	if (IS_ERR(ap1302->reset_gpio)) {
+		ret = PTR_ERR(ap1302->reset_gpio);
+
+		dev_err(ap1302->dev, "Can't get reset GPIO: %i\n", ret);
+
+		return ret;
+	}
+
+	ap1302->standby_gpio = devm_gpiod_get_optional(ap1302->dev, "standby",
+						       GPIOD_OUT_LOW);
+	if (IS_ERR(ap1302->standby_gpio)) {
+		ret = PTR_ERR(ap1302->standby_gpio);
+
+		dev_err(ap1302->dev, "Can't get standby GPIO: %i\n", ret);
+
+		return ret;
+	}
+
+	ap1302->vcc_supply = devm_regulator_get_optional(ap1302->dev, "vcc");
+	if (IS_ERR(ap1302->vcc_supply)) {
+		ret = PTR_ERR(ap1302->vcc_supply);
+
+		if (ret == -ENODEV) {
+			dev_warn(ap1302->dev, "vcc supply not found\n");
+			ap1302->vcc_supply = NULL;
+		} else {
+			dev_err(ap1302->dev, "Can't get vcc supply: %i\n", ret);
+
+			return ret;
+		}
+	}
+
+	/* Bus configuration */
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(ap1302->dev), NULL);
+	if (!ep)
+		return -EINVAL;
+
+	ap1302->bus_cfg.bus_type = V4L2_MBUS_CSI2_DPHY;
+
+	ret = v4l2_fwnode_endpoint_alloc_parse(ep, &ap1302->bus_cfg);
+	if (ret) {
+		dev_err(ap1302->dev, "Failed to parse bus configuration\n");
+
+		return ret;
+	}
+
+	if (!ap1302->bus_cfg.nr_of_link_frequencies) {
+		dev_err(ap1302->dev, "no link frequencies defined");
+
+		return -EINVAL;
+	}
+
+	/* Sensors */
+	sensors = of_get_child_by_name(ap1302->dev->of_node, "sensors");
+	if (!sensors) {
+		memcpy(&ap1302->sensor_info, &ap1302_sensor_info_tpg,
+		       sizeof(ap1302_sensor_info_tpg));
+		if (!ap1302->nvmem)
+			dev_warn(ap1302->dev,
+				 "no sensors node found, using tpg\n");
+	} else {
+		if (!ap1302->nvmem) {
+			ret = of_property_read_string(sensors, "sensor,model",
+						      &ap1302->sensor_info.model);
+			if (ret < 0) {
+				dev_err(ap1302->dev,
+					"missing sensor,model info\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			dev_dbg(ap1302->dev, "sensor,model '%s'\n",
+				ap1302->sensor_info.model);
+		}
+
+		ret = of_property_read_u32_array(sensors, "sensor,resolution",
+			(u32 *)&ap1302->sensor_info.resolution, 2);
+		if (ret < 0) {
+			dev_err(ap1302->dev, "missing sensor,resolution info\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		dev_dbg(ap1302->dev, "sensor,resolution %d x %d\n",
+			ap1302->sensor_info.resolution.width,
+			ap1302->sensor_info.resolution.height);
+
+		ret = of_property_read_u32(sensors, "sensor,format",
+					   &ap1302->sensor_info.format);
+		if (ret < 0) {
+			dev_err(ap1302->dev, "missing sensor,format info\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		dev_dbg(ap1302->dev, "sensor,format 0x%x\n",
+			ap1302->sensor_info.format);
+
+		ap1302->primary_clk_rst_only = of_property_read_bool(sensors,
+			"sensor,primary-clk-rst-only");
+		if (ap1302->primary_clk_rst_only) {
+			dev_dbg(ap1302->dev,
+				"using primary sensor clock and reset only");
+		}
+	}
+
+	for_each_child_of_node(sensors, node) {
+		if (of_node_name_eq(node, "sensor")) {
+			ret = ap1302_sensor_parse_of(ap1302, node);
+			if (ret)
+				break;
+		}
+	}
+
+done:
+	of_node_put(sensors);
+
+	return ret;
+}
+
+static void ap1302_cleanup(struct ap1302_device *ap1302)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
+		struct ap1302_sensor *sensor = &ap1302->sensors[i];
+
+		if (!sensor->ap1302)
+			continue;
+
+		ap1302_sensor_cleanup(sensor);
+	}
+
+	v4l2_fwnode_endpoint_free(&ap1302->bus_cfg);
+
+	device_remove_file(ap1302->dev, &dev_attr_stall_standby);
+	device_remove_file(ap1302->dev, &dev_attr_lane_status);
+
+	mutex_destroy(&ap1302->lock);
+}
+
+static int ap1302_probe(struct i2c_client *client)
+{
+	struct ap1302_device *ap1302;
+	unsigned int i;
+	int ret;
+
+	ap1302 = devm_kzalloc(&client->dev, sizeof(*ap1302), GFP_KERNEL);
+	if (!ap1302)
+		return -ENOMEM;
+
+	ap1302->dev = &client->dev;
+	ap1302->client = client;
+
+	/* NVMEM */
+	ap1302->nvmem = devm_nvmem_device_get(ap1302->dev, NULL);
+	if (IS_ERR(ap1302->nvmem)) {
+		if (PTR_ERR(ap1302->nvmem) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		
+		ap1302->nvmem = NULL;
+	}
+
+	dev_info(ap1302->dev, "AP1302 Driver probe\n");
+
+	ap1302->regmap16 = devm_regmap_init_i2c(client, &ap1302_reg16_config);
+	if (IS_ERR(ap1302->regmap16))
+		return PTR_ERR(ap1302->regmap16);
+
+	ap1302->regmap32 = devm_regmap_init_i2c(client, &ap1302_reg32_config);
+	if (IS_ERR(ap1302->regmap32))
+		return PTR_ERR(ap1302->regmap16);
+
+	mutex_init(&ap1302->lock);
+
+	ret = ap1302_parse_of(ap1302);
+	if (ret < 0)
+		goto error;
+
+	for (i = 0; i < ARRAY_SIZE(ap1302->sensors); ++i) {
+		struct ap1302_sensor *sensor = &ap1302->sensors[i];
+
+		/*
+		 * all sensor initialized, v4l link determine single/dual
+		 */
+		ap1302->sensors[i].ap1302 = ap1302;
+
+		ret = ap1302_sensor_init(sensor, i);
+		if (ret < 0)
+			goto error;
+	}
+
+	ret = ap1302_hw_init(ap1302);
+	if (ret)
+		goto error;
+
+	ret = device_create_file(ap1302->dev, &dev_attr_stall_standby);
+	ret |= device_create_file(ap1302->dev, &dev_attr_lane_status);
+	if (ret) {
+		dev_err(ap1302->dev, "could not register sysfs entry\n");
+		goto error_hw_cleanup;
+	}
+
+	ap1302_debugfs_init(ap1302);
+
+	ret = ap1302_config_v4l2(ap1302);
+	if (!ret)
+		return 0;
+
+error_hw_cleanup:
+	ap1302_hw_cleanup(ap1302);
+
+error:
+	ap1302_cleanup(ap1302);
+
+	return ret;
+}
+
+static void ap1302_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ap1302_device *ap1302 = to_ap1302(sd);
+
+	ap1302_debugfs_cleanup(ap1302);
+
+	ap1302_hw_cleanup(ap1302);
+
+	release_firmware(ap1302->fw);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+
+	ap1302_ctrls_cleanup(ap1302);
+
+	ap1302_cleanup(ap1302);
+}
+
+static const struct of_device_id ap1302_of_id_table[] = {
+	{ .compatible = "onnn,ap1302" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ap1302_of_id_table);
+
+static struct i2c_driver ap1302_i2c_driver = {
+	.driver = {
+		.name	= DRIVER_NAME,
+		.of_match_table	= ap1302_of_id_table,
+	},
+	.probe		= ap1302_probe,
+	.remove		= ap1302_remove,
+};
+module_i2c_driver(ap1302_i2c_driver);
+
+MODULE_AUTHOR("Florian Rebaudo <frebaudo@witekio.com>");
+MODULE_AUTHOR("Stan Bertrand <sbertrand@witekio.com>");
+MODULE_AUTHOR("Laurent Pinchart <laurent.pinchart@ideasonboard.com>");
+MODULE_AUTHOR("Anil Kumar M <anil.mamidala@xilinx.com>");
+
+MODULE_DESCRIPTION("ON Semiconductor AP1302 ISP driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index 36b509714c8c..8b7ff2f3bdda 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -568,9 +568,7 @@ static const struct reg_value ov5640_init_setting[] = {
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
 	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
 	{0x302e, 0x08, 0, 0}, {0x4300, 0x3f, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x440e, 0x00, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x4837, 0x0a, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x501f, 0x00, 0, 0}, {0x440e, 0x00, 0, 0}, {0x4837, 0x0a, 0, 0},
 	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
 	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
 	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
@@ -634,7 +632,8 @@ static const struct reg_value ov5640_setting_low_res[] = {
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
+	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_720P_1280_720[] = {
@@ -2453,16 +2452,13 @@ static void ov5640_power(struct ov5640_dev *sensor, bool enable)
 static void ov5640_powerup_sequence(struct ov5640_dev *sensor)
 {
 	if (sensor->pwdn_gpio) {
-		gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+		gpiod_set_value_cansleep(sensor->reset_gpio, 1);
 
 		/* camera power cycle */
 		ov5640_power(sensor, false);
-		usleep_range(5000, 10000);
+		usleep_range(5000, 10000);	/* t2 */
 		ov5640_power(sensor, true);
-		usleep_range(5000, 10000);
-
-		gpiod_set_value_cansleep(sensor->reset_gpio, 1);
-		usleep_range(1000, 2000);
+		usleep_range(1000, 2000);	/* t3 */
 
 		gpiod_set_value_cansleep(sensor->reset_gpio, 0);
 	} else {
@@ -2470,7 +2466,7 @@ static void ov5640_powerup_sequence(struct ov5640_dev *sensor)
 		ov5640_write_reg(sensor, OV5640_REG_SYS_CTRL0,
 				 OV5640_REG_SYS_CTRL0_SW_RST);
 	}
-	usleep_range(20000, 25000);
+	usleep_range(20000, 25000);	/* t4 */
 
 	/*
 	 * software standby: allows registers programming;
@@ -2543,9 +2539,9 @@ static int ov5640_set_power_mipi(struct ov5640_dev *sensor, bool on)
 	 *		  "ov5640_set_stream_mipi()")
 	 * [4] = 0	: Power up MIPI HS Tx
 	 * [3] = 0	: Power up MIPI LS Rx
-	 * [2] = 0	: MIPI interface disabled
+	 * [2] = 1	: MIPI interface enabled
 	 */
-	ret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x40);
+	ret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x44);
 	if (ret)
 		return ret;
 
diff --git a/drivers/media/platform/nxp/imx-mipi-csis.c b/drivers/media/platform/nxp/imx-mipi-csis.c
index 05d52762e792..4780f5654d76 100644
--- a/drivers/media/platform/nxp/imx-mipi-csis.c
+++ b/drivers/media/platform/nxp/imx-mipi-csis.c
@@ -596,6 +596,9 @@ static int mipi_csis_calculate_params(struct mipi_csis_device *csis,
 	s64 link_freq;
 	u32 lane_rate;
 
+	if (!csis->src_sd)
+		return -EINVAL;
+
 	/* Calculate the line rate from the pixel rate. */
 	link_freq = v4l2_get_link_freq(csis->src_sd->ctrl_handler,
 				       csis_fmt->width,
diff --git a/drivers/media/platform/nxp/imx7-media-csi.c b/drivers/media/platform/nxp/imx7-media-csi.c
index 791bde67f439..8af71c89f8dc 100644
--- a/drivers/media/platform/nxp/imx7-media-csi.c
+++ b/drivers/media/platform/nxp/imx7-media-csi.c
@@ -1076,6 +1076,7 @@ static int imx7_csi_video_enum_framesizes(struct file *file, void *fh,
 					  struct v4l2_frmsizeenum *fsize)
 {
 	const struct imx7_csi_pixfmt *cc;
+	u32 walign;
 
 	if (fsize->index > 0)
 		return -EINVAL;
@@ -1085,16 +1086,17 @@ static int imx7_csi_video_enum_framesizes(struct file *file, void *fh,
 		return -EINVAL;
 
 	/*
-	 * TODO: The constraints are hardware-specific and may depend on the
-	 * pixel format. This should come from the driver using
-	 * imx_media_capture.
+	 * The width alignment is 8 bytes as indicated by the
+	 * CSI_IMAG_PARA.IMAGE_WIDTH documentation. Convert it to pixels.
 	 */
+	walign = 8 * 8 / cc->bpp;
+
 	fsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
-	fsize->stepwise.min_width = 1;
-	fsize->stepwise.max_width = 65535;
+	fsize->stepwise.min_width = walign;
+	fsize->stepwise.max_width = round_down(65535U, walign);
 	fsize->stepwise.min_height = 1;
 	fsize->stepwise.max_height = 65535;
-	fsize->stepwise.step_width = 1;
+	fsize->stepwise.step_width = walign;
 	fsize->stepwise.step_height = 1;
 
 	return 0;
diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
index a5c5036dfb94..4396f3c3c114 100644
--- a/drivers/net/can/Kconfig
+++ b/drivers/net/can/Kconfig
@@ -217,6 +217,7 @@ source "drivers/net/can/m_can/Kconfig"
 source "drivers/net/can/mscan/Kconfig"
 source "drivers/net/can/peak_canfd/Kconfig"
 source "drivers/net/can/rcar/Kconfig"
+source "drivers/net/can/rockchip/Kconfig"
 source "drivers/net/can/sja1000/Kconfig"
 source "drivers/net/can/softing/Kconfig"
 source "drivers/net/can/spi/Kconfig"
diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
index ff8f76295d13..5140da19fc95 100644
--- a/drivers/net/can/Makefile
+++ b/drivers/net/can/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_CAN_SLCAN)		+= slcan/
 
 obj-y				+= dev/
 obj-y				+= rcar/
+obj-y				+= rockchip/
 obj-y				+= spi/
 obj-y				+= usb/
 obj-y				+= softing/
diff --git a/drivers/net/can/rockchip/Kconfig b/drivers/net/can/rockchip/Kconfig
new file mode 100644
index 000000000000..775ff80d9a81
--- /dev/null
+++ b/drivers/net/can/rockchip/Kconfig
@@ -0,0 +1,8 @@
+config CANFD_ROCKCHIP
+	tristate "Rockchip CANFD controller"
+	depends on ARCH_ROCKCHIP
+	help
+	  Say Y here if you want to use CANFD controller found on Rockchip SoCs.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called rockchip_canfd.
diff --git a/drivers/net/can/rockchip/Makefile b/drivers/net/can/rockchip/Makefile
new file mode 100644
index 000000000000..1619d4dcfc6d
--- /dev/null
+++ b/drivers/net/can/rockchip/Makefile
@@ -0,0 +1,5 @@
+#
+#  Makefile for the rockchip can and canfd controller driver.
+#
+
+obj-$(CONFIG_CANFD_ROCKCHIP)	+= rockchip_canfd.o
diff --git a/drivers/net/can/rockchip/rockchip_canfd.c b/drivers/net/can/rockchip/rockchip_canfd.c
new file mode 100644
index 000000000000..287b73893b39
--- /dev/null
+++ b/drivers/net/can/rockchip/rockchip_canfd.c
@@ -0,0 +1,1078 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co. Ltd.
+ * Rockchip CANFD driver
+ */
+
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/clk.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/can/dev.h>
+#include <linux/can/error.h>
+#include <linux/reset.h>
+#include <linux/pm_runtime.h>
+
+/* registers definition */
+enum rockchip_canfd_reg {
+	CAN_MODE = 0x00,
+	CAN_CMD = 0x04,
+	CAN_STATE = 0x08,
+	CAN_INT = 0x0c,
+	CAN_INT_MASK = 0x10,
+	CAN_LOSTARB_CODE = 0x28,
+	CAN_ERR_CODE = 0x2c,
+	CAN_RX_ERR_CNT = 0x34,
+	CAN_TX_ERR_CNT = 0x38,
+	CAN_IDCODE = 0x3c,
+	CAN_IDMASK = 0x40,
+	CAN_NBTP = 0x100,
+	CAN_DBTP = 0x104,
+	CAN_TDCR = 0x108,
+	CAN_TSCC = 0x10c,
+	CAN_TSCV = 0x110,
+	CAN_TXEFC = 0x114,
+	CAN_RXFC = 0x118,
+	CAN_AFC = 0x11c,
+	CAN_IDCODE0 = 0x120,
+	CAN_IDMASK0 = 0x124,
+	CAN_IDCODE1 = 0x128,
+	CAN_IDMASK1 = 0x12c,
+	CAN_IDCODE2 = 0x130,
+	CAN_IDMASK2 = 0x134,
+	CAN_IDCODE3 = 0x138,
+	CAN_IDMASK3 = 0x13c,
+	CAN_IDCODE4 = 0x140,
+	CAN_IDMASK4 = 0x144,
+	CAN_TXFIC = 0x200,
+	CAN_TXID = 0x204,
+	CAN_TXDAT0 = 0x208,
+	CAN_TXDAT1 = 0x20c,
+	CAN_TXDAT2 = 0x210,
+	CAN_TXDAT3 = 0x214,
+	CAN_TXDAT4 = 0x218,
+	CAN_TXDAT5 = 0x21c,
+	CAN_TXDAT6 = 0x220,
+	CAN_TXDAT7 = 0x224,
+	CAN_TXDAT8 = 0x228,
+	CAN_TXDAT9 = 0x22c,
+	CAN_TXDAT10 = 0x230,
+	CAN_TXDAT11 = 0x234,
+	CAN_TXDAT12 = 0x238,
+	CAN_TXDAT13 = 0x23c,
+	CAN_TXDAT14 = 0x240,
+	CAN_TXDAT15 = 0x244,
+	CAN_RXFIC = 0x300,
+	CAN_RXID = 0x304,
+	CAN_RXTS = 0x308,
+	CAN_RXDAT0 = 0x30c,
+	CAN_RXDAT1 = 0x310,
+	CAN_RXDAT2 = 0x314,
+	CAN_RXDAT3 = 0x318,
+	CAN_RXDAT4 = 0x31c,
+	CAN_RXDAT5 = 0x320,
+	CAN_RXDAT6 = 0x324,
+	CAN_RXDAT7 = 0x328,
+	CAN_RXDAT8 = 0x32c,
+	CAN_RXDAT9 = 0x330,
+	CAN_RXDAT10 = 0x334,
+	CAN_RXDAT11 = 0x338,
+	CAN_RXDAT12 = 0x33c,
+	CAN_RXDAT13 = 0x340,
+	CAN_RXDAT14 = 0x344,
+	CAN_RXDAT15 = 0x348,
+	CAN_RXFRD = 0x400,
+	CAN_TXEFRD = 0x500,
+};
+
+#define DATE_LENGTH_12_BYTE	(0x9)
+#define DATE_LENGTH_16_BYTE	(0xa)
+#define DATE_LENGTH_20_BYTE	(0xb)
+#define DATE_LENGTH_24_BYTE	(0xc)
+#define DATE_LENGTH_32_BYTE	(0xd)
+#define DATE_LENGTH_48_BYTE	(0xe)
+#define DATE_LENGTH_64_BYTE	(0xf)
+
+#define CAN_TX0_REQ		BIT(0)
+#define CAN_TX1_REQ		BIT(1)
+#define CAN_TX_REQ_FULL		((CAN_TX0_REQ) | (CAN_TX1_REQ))
+
+#define MODE_FDOE		BIT(15)
+#define MODE_BRSD		BIT(13)
+#define MODE_SPACE_RX		BIT(12)
+#define MODE_AUTO_RETX		BIT(10)
+#define MODE_RXSORT		BIT(7)
+#define MODE_TXORDER		BIT(6)
+#define MODE_RXSTX		BIT(5)
+#define MODE_LBACK		BIT(4)
+#define MODE_SILENT		BIT(3)
+#define MODE_SELF_TEST		BIT(2)
+#define MODE_SLEEP		BIT(1)
+#define RESET_MODE		0
+#define WORK_MODE		BIT(0)
+
+#define RX_PERIOD		BIT(2)
+
+#define RX_FINISH_INT		BIT(0)
+#define TX_FINISH_INT		BIT(1)
+#define ERR_WARN_INT		BIT(2)
+#define RX_BUF_OV_INT		BIT(3)
+#define PASSIVE_ERR_INT		BIT(4)
+#define TX_LOSTARB_INT		BIT(5)
+#define BUS_ERR_INT		BIT(6)
+#define RX_FIFO_FULL_INT	BIT(7)
+#define RX_FIFO_OV_INT		BIT(8)
+#define BUS_OFF_INT		BIT(9)
+#define BUS_OFF_RECOVERY_INT	BIT(10)
+#define TSC_OV_INT		BIT(11)
+#define TXE_FIFO_OV_INT		BIT(12)
+#define TXE_FIFO_FULL_INT	BIT(13)
+#define WAKEUP_INT		BIT(14)
+
+#define ERR_TYPE_MASK		GENMASK(28, 26)
+#define ERR_TYPE_SHIFT		26
+#define BIT_ERR			0
+#define STUFF_ERR		1
+#define FORM_ERR		2
+#define ACK_ERR			3
+#define CRC_ERR			4
+#define ERR_DIR_RX		BIT(25)
+#define ERR_LOC_MASK		GENMASK(15, 0)
+
+/* Nominal Bit Timing & Prescaler Register (NBTP) */
+#define NBTP_MODE_3_SAMPLES	BIT(31)
+#define NBTP_NSJW_SHIFT		24
+#define NBTP_NSJW_MASK		(0x7f << NBTP_NSJW_SHIFT)
+#define NBTP_NBRP_SHIFT		16
+#define NBTP_NBRP_MASK		(0xff << NBTP_NBRP_SHIFT)
+#define NBTP_NTSEG2_SHIFT	8
+#define NBTP_NTSEG2_MASK	(0x7f << NBTP_NTSEG2_SHIFT)
+#define NBTP_NTSEG1_SHIFT	0
+#define NBTP_NTSEG1_MASK	(0x7f << NBTP_NTSEG1_SHIFT)
+
+/* Data Bit Timing & Prescaler Register (DBTP) */
+#define DBTP_MODE_3_SAMPLES	BIT(21)
+#define DBTP_DSJW_SHIFT		17
+#define DBTP_DSJW_MASK		(0xf << DBTP_DSJW_SHIFT)
+#define DBTP_DBRP_SHIFT		9
+#define DBTP_DBRP_MASK		(0xff << DBTP_DBRP_SHIFT)
+#define DBTP_DTSEG2_SHIFT	5
+#define DBTP_DTSEG2_MASK	(0xf << DBTP_DTSEG2_SHIFT)
+#define DBTP_DTSEG1_SHIFT	0
+#define DBTP_DTSEG1_MASK	(0x1f << DBTP_DTSEG1_SHIFT)
+
+/* Transmitter Delay Compensation Register (TDCR) */
+#define TDCR_TDCO_SHIFT		1
+#define TDCR_TDCO_MASK		(0x3f << TDCR_TDCO_SHIFT)
+#define TDCR_TDC_ENABLE		BIT(0)
+
+#define TX_FD_ENABLE		BIT(5)
+#define TX_FD_BRS_ENABLE	BIT(4)
+
+#define FIFO_ENABLE		BIT(0)
+
+#define FORMAT_SHIFT		7
+#define FORMAT_MASK		(0x1 << FORMAT_SHIFT)
+#define RTR_SHIFT		6
+#define RTR_MASK		(0x1 << RTR_SHIFT)
+#define FDF_SHIFT		5
+#define FDF_MASK		(0x1 << FDF_SHIFT)
+#define BRS_SHIFT		4
+#define BRS_MASK		(0x1 << BRS_SHIFT)
+#define DLC_SHIFT		0
+#define DLC_MASK		(0xF << DLC_SHIFT)
+
+#define CAN_RF_SIZE		0x48
+#define CAN_TEF_SIZE		0x8
+#define CAN_TXEFRD_OFFSET(n)	(CAN_TXEFRD + CAN_TEF_SIZE * (n))
+#define CAN_RXFRD_OFFSET(n)	(CAN_RXFRD + CAN_RF_SIZE * (n))
+
+#define CAN_RX_FILTER_MASK	0x1fffffff
+
+#define DRV_NAME	"rockchip_canfd"
+
+/* rockchip_canfd private data structure */
+
+struct rockchip_canfd {
+	struct can_priv can;
+	struct device *dev;
+	spinlock_t tx_lock;
+	struct napi_struct napi;
+	struct clk_bulk_data *clks;
+	int num_clks;
+	struct reset_control *reset;
+	void __iomem *base;
+	u32 irqstatus;
+	u32 data[120];
+};
+
+static inline u32 rockchip_canfd_read(const struct rockchip_canfd *priv,
+				      enum rockchip_canfd_reg reg)
+{
+	return readl(priv->base + reg);
+}
+
+static inline void rockchip_canfd_write(const struct rockchip_canfd *priv,
+					enum rockchip_canfd_reg reg, u32 val)
+{
+	writel(val, priv->base + reg);
+}
+
+static const struct can_bittiming_const rockchip_canfd_bittiming_const = {
+	.name = DRV_NAME,
+	.tseg1_min = 1,
+	.tseg1_max = 128,
+	.tseg2_min = 1,
+	.tseg2_max = 128,
+	.sjw_max = 128,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 2,
+};
+
+static const struct can_bittiming_const rockchip_canfd_data_bittiming_const = {
+	.name = DRV_NAME,
+	.tseg1_min = 1,
+	.tseg1_max = 32,
+	.tseg2_min = 1,
+	.tseg2_max = 16,
+	.sjw_max = 16,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 2,
+};
+
+static int set_reset_mode(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+
+	reset_control_assert(rcan->reset);
+	udelay(2);
+	reset_control_deassert(rcan->reset);
+
+	rockchip_canfd_write(rcan, CAN_MODE, 0);
+
+	netdev_dbg(ndev, "%s MODE=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_MODE));
+
+	return 0;
+}
+
+static int set_normal_mode(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	u32 val;
+
+	val = rockchip_canfd_read(rcan, CAN_MODE);
+	val |= WORK_MODE;
+	rockchip_canfd_write(rcan, CAN_MODE, val);
+
+	netdev_dbg(ndev, "%s MODE=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_MODE));
+	return 0;
+}
+
+/* bittiming is called in reset_mode only */
+static int rockchip_canfd_set_bittiming(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	const struct can_bittiming *bt = &rcan->can.bittiming;
+	const struct can_bittiming *dbt = &rcan->can.data_bittiming;
+	u16 brp, sjw, tseg1, tseg2;
+	u32 reg_btp;
+
+	brp = (bt->brp >> 1) - 1;
+	sjw = bt->sjw - 1;
+	tseg1 = bt->prop_seg + bt->phase_seg1 - 1;
+	tseg2 = bt->phase_seg2 - 1;
+	reg_btp = (brp << NBTP_NBRP_SHIFT) | (sjw << NBTP_NSJW_SHIFT) |
+		  (tseg1 << NBTP_NTSEG1_SHIFT) |
+		  (tseg2 << NBTP_NTSEG2_SHIFT);
+
+	if (rcan->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)
+		reg_btp |= NBTP_MODE_3_SAMPLES;
+
+	rockchip_canfd_write(rcan, CAN_NBTP, reg_btp);
+
+	if (rcan->can.ctrlmode & CAN_CTRLMODE_FD) {
+		reg_btp = 0;
+		brp = (dbt->brp >> 1) - 1;
+		sjw = dbt->sjw - 1;
+		tseg1 = dbt->prop_seg + dbt->phase_seg1 - 1;
+		tseg2 = dbt->phase_seg2 - 1;
+
+		if (dbt->bitrate > 2200000) {
+			u32 tdco;
+
+			/* Equation based on Bosch's ROCKCHIP_CAN User Manual's
+			 * Transmitter Delay Compensation Section
+			 */
+			tdco = (rcan->can.clock.freq / dbt->bitrate) * 2 / 3;
+			/* Max valid TDCO value is 63 */
+			if (tdco > 63)
+				tdco = 63;
+
+			rockchip_canfd_write(rcan, CAN_TDCR,
+					     (tdco << TDCR_TDCO_SHIFT) |
+					     TDCR_TDC_ENABLE);
+		}
+
+		reg_btp |= (brp << DBTP_DBRP_SHIFT) |
+			   (sjw << DBTP_DSJW_SHIFT) |
+			   (tseg1 << DBTP_DTSEG1_SHIFT) |
+			   (tseg2 << DBTP_DTSEG2_SHIFT);
+
+		if (rcan->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)
+			reg_btp |= DBTP_MODE_3_SAMPLES;
+
+		rockchip_canfd_write(rcan, CAN_DBTP, reg_btp);
+	}
+
+	netdev_dbg(ndev, "%s NBTP=0x%08x, DBTP=0x%08x, TDCR=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_NBTP),
+		   rockchip_canfd_read(rcan, CAN_DBTP),
+		   rockchip_canfd_read(rcan, CAN_TDCR));
+	return 0;
+}
+
+static int rockchip_canfd_get_berr_counter(const struct net_device *ndev,
+					   struct can_berr_counter *bec)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	int err;
+
+	err = pm_runtime_get_sync(rcan->dev);
+	if (err < 0) {
+		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
+			   __func__, err);
+		return err;
+	}
+
+	bec->rxerr = rockchip_canfd_read(rcan, CAN_RX_ERR_CNT);
+	bec->txerr = rockchip_canfd_read(rcan, CAN_TX_ERR_CNT);
+
+	pm_runtime_put(rcan->dev);
+
+	netdev_dbg(ndev, "%s RX_ERR_CNT=0x%08x, TX_ERR_CNT=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_RX_ERR_CNT),
+		   rockchip_canfd_read(rcan, CAN_TX_ERR_CNT));
+
+	return 0;
+}
+
+static int rockchip_canfd_start(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	u32 val;
+
+	/* we need to enter the reset mode */
+	set_reset_mode(ndev);
+
+	rockchip_canfd_write(rcan, CAN_INT_MASK, 0);
+
+	/* RECEIVING FILTER, accept all */
+	rockchip_canfd_write(rcan, CAN_IDCODE, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK, CAN_RX_FILTER_MASK);
+	rockchip_canfd_write(rcan, CAN_IDCODE0, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK0, CAN_RX_FILTER_MASK);
+	rockchip_canfd_write(rcan, CAN_IDCODE1, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK1, CAN_RX_FILTER_MASK);
+	rockchip_canfd_write(rcan, CAN_IDCODE2, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK2, CAN_RX_FILTER_MASK);
+	rockchip_canfd_write(rcan, CAN_IDCODE3, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK3, CAN_RX_FILTER_MASK);
+	rockchip_canfd_write(rcan, CAN_IDCODE4, 0);
+	rockchip_canfd_write(rcan, CAN_IDMASK4, CAN_RX_FILTER_MASK);
+
+	/* set mode */
+	val = rockchip_canfd_read(rcan, CAN_MODE);
+
+	/* rx fifo enable */
+	rockchip_canfd_write(rcan, CAN_RXFC,
+			     rockchip_canfd_read(rcan, CAN_RXFC) | FIFO_ENABLE);
+
+	/* Canfd Mode */
+	if (rcan->can.ctrlmode & CAN_CTRLMODE_FD) {
+		val |= MODE_FDOE;
+		rockchip_canfd_write(rcan, CAN_TXFIC,
+				     rockchip_canfd_read(rcan, CAN_TXFIC) |
+				     TX_FD_ENABLE);
+	}
+
+	/* Loopback Mode */
+	if (rcan->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)
+		val |= MODE_SELF_TEST | MODE_LBACK;
+
+	val |= MODE_AUTO_RETX;
+
+	rockchip_canfd_write(rcan, CAN_MODE, val);
+
+	rockchip_canfd_set_bittiming(ndev);
+
+	set_normal_mode(ndev);
+
+	rcan->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	netdev_dbg(ndev, "%s MODE=0x%08x, INT_MASK=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_MODE),
+		   rockchip_canfd_read(rcan, CAN_INT_MASK));
+
+	return 0;
+}
+
+static int rockchip_canfd_stop(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+
+	rcan->can.state = CAN_STATE_STOPPED;
+	/* we need to enter reset mode */
+	set_reset_mode(ndev);
+
+	/* disable all interrupts */
+	rockchip_canfd_write(rcan, CAN_INT_MASK, 0xffff);
+
+	netdev_dbg(ndev, "%s MODE=0x%08x, INT_MASK=0x%08x\n", __func__,
+		   rockchip_canfd_read(rcan, CAN_MODE),
+		   rockchip_canfd_read(rcan, CAN_INT_MASK));
+	return 0;
+}
+
+static int rockchip_canfd_set_mode(struct net_device *ndev,
+				   enum can_mode mode)
+{
+	int err;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		err = rockchip_canfd_start(ndev);
+		if (err) {
+			netdev_err(ndev, "starting CAN controller failed!\n");
+			return err;
+		}
+		if (netif_queue_stopped(ndev))
+			netif_wake_queue(ndev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+/* transmit a CAN message
+ * message layout in the sk_buff should be like this:
+ * xx xx xx xx         ff         ll 00 11 22 33 44 55 66 77
+ * [ can_id ] [flags] [len] [can data (up to 8 bytes]
+ */
+static int rockchip_canfd_start_xmit(struct sk_buff *skb,
+				     struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	struct canfd_frame *cf = (struct canfd_frame *)skb->data;
+	u32 id, dlc;
+	u32 cmd = CAN_TX0_REQ, mode;
+	int i;
+//	unsigned long flags;
+
+	if (can_dropped_invalid_skb(ndev, skb))
+		return NETDEV_TX_OK;
+
+//	spin_lock_irqsave(&rcan->tx_lock, flags);
+	can_put_echo_skb(skb, ndev, 0, 0);
+
+	netif_stop_queue(ndev);
+
+	if (rockchip_canfd_read(rcan, CAN_CMD) & CAN_TX0_REQ)
+		cmd = CAN_TX1_REQ;
+
+	/* Watch carefully on the bit sequence */
+	if (cf->can_id & CAN_EFF_FLAG) {
+		/* Extended CAN ID format */
+		id = cf->can_id & CAN_EFF_MASK;
+		dlc = can_fd_len2dlc(cf->len) & DLC_MASK;
+		dlc |= FORMAT_MASK;
+		/* Extended frames need workround */
+		if ((rockchip_canfd_read(rcan, CAN_STATE) & RX_PERIOD) == 0) {
+			mode = rockchip_canfd_read(rcan, CAN_MODE);
+			rockchip_canfd_write(rcan, CAN_MODE,
+					     mode | MODE_SLEEP);
+			mode = rockchip_canfd_read(rcan, CAN_MODE);
+			rockchip_canfd_write(rcan, CAN_MODE,
+					     mode & (~MODE_SLEEP));
+		}
+		/* Extended frames remote TX request */
+		if (cf->can_id & CAN_RTR_FLAG)
+			dlc |= RTR_MASK;
+	} else {
+		/* Standard CAN ID format */
+		id = cf->can_id & CAN_SFF_MASK;
+		dlc = can_fd_len2dlc(cf->len) & DLC_MASK;
+
+		/* Standard frames remote TX request */
+		if (cf->can_id & CAN_RTR_FLAG)
+			dlc |= RTR_MASK;
+	}
+
+	if ((rcan->can.ctrlmode & CAN_CTRLMODE_FD) && can_is_canfd_skb(skb)) {
+		dlc |= TX_FD_ENABLE;
+		if (cf->flags & CANFD_BRS)
+			dlc |= TX_FD_BRS_ENABLE;
+	}
+
+	rockchip_canfd_write(rcan, CAN_TXID, id);
+	rockchip_canfd_write(rcan, CAN_TXFIC, dlc);
+
+	for (i = 0; i < cf->len; i += 4)
+		rockchip_canfd_write(rcan, CAN_TXDAT0 + i,
+				     *(u32 *)(cf->data + i));
+
+	rockchip_canfd_write(rcan, CAN_CMD, cmd);
+
+	//can_put_echo_skb(skb, ndev, 0);
+
+//	spin_unlock_irqrestore(&rcan->tx_lock, flags);
+
+	return NETDEV_TX_OK;
+}
+
+static int rockchip_canfd_rx(struct net_device *ndev, int frame)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	struct net_device_stats *stats = &ndev->stats;
+	struct canfd_frame *cf;
+	struct sk_buff *skb;
+	u32 id_rockchip_canfd, dlc;
+	int i = 0;
+	u32 __maybe_unused ts, ret;
+	u32 data[16] = {0};
+//	unsigned long flags;
+
+//	spin_lock_irqsave(&rcan->tx_lock, flags);
+
+#if 1
+	dlc = rcan->data[frame * 18];
+	id_rockchip_canfd = rcan->data[frame * 18 + 1];
+	ts = rcan->data[frame * 18 + 2];
+	for (i = 0; i < 16; i++)
+		data[i] = rcan->data[frame * 18 + i + 3];
+#else
+	dlc = rockchip_canfd_read(rcan, CAN_RXFRD);;
+	id_rockchip_canfd = rockchip_canfd_read(rcan, CAN_RXFRD);;
+	ts = rockchip_canfd_read(rcan, CAN_RXFRD);;
+	for (i = 0; i < 16; i++)
+		data[i] = rockchip_canfd_read(rcan, CAN_RXFRD);;
+#endif
+	/* create zero'ed CAN frame buffer */
+	if (dlc & FDF_MASK)
+		skb = alloc_canfd_skb(ndev, &cf);
+	else
+		skb = alloc_can_skb(ndev, (struct can_frame **)&cf);
+	if (!skb) {
+		stats->rx_dropped++;
+		//spin_unlock_irqrestore(&rcan->tx_lock, flags);
+		return 0;
+	}
+
+	/* Change CAN data length format to socketCAN data format */
+	if (dlc & FDF_MASK)
+		cf->len = can_fd_dlc2len(dlc & DLC_MASK);
+	else
+		cf->len = can_fd_dlc2len(dlc & DLC_MASK);
+
+	/* Change CAN ID format to socketCAN ID format */
+	if (dlc & FORMAT_MASK) {
+		/* The received frame is an Extended format frame */
+		cf->can_id = id_rockchip_canfd;
+		cf->can_id |= CAN_EFF_FLAG;
+		if (dlc & RTR_MASK)
+			cf->can_id |= CAN_RTR_FLAG;
+	} else {
+		/* The received frame is a standard format frame */
+		cf->can_id = id_rockchip_canfd;
+		if (dlc & RTR_MASK)
+			cf->can_id |= CAN_RTR_FLAG;
+	}
+
+	if (dlc & BRS_MASK)
+		cf->flags |= CANFD_BRS;
+
+	if (!(cf->can_id & CAN_RTR_FLAG)) {
+		/* Change CAN data format to socketCAN data format */
+		for (i = 0; i < cf->len; i += 4)
+			*(u32 *)(cf->data + i) = data[i / 4];
+	}
+
+	stats->rx_packets++;
+	stats->rx_bytes += cf->len;
+	netif_rx(skb);
+
+//	spin_unlock_irqrestore(&rcan->tx_lock, flags);
+
+	return 1;
+}
+/**
+ * rockchip_canfd_rx_poll - Poll routine for rx packets (NAPI)
+ * @napi:	napi structure pointer
+ * @quota:	Max number of rx packets to be processed.
+ *
+ * This is the poll routine for rx part.
+ * It will process the packets maximux quota value.
+ *
+ * Return: number of packets received
+ */
+static int  rockchip_canfd_rx_poll(struct napi_struct *napi, int quota)
+{
+	struct net_device *ndev = napi->dev;
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	int work_done = 0, i = 0;
+	int frame = 0;
+
+	quota = (rockchip_canfd_read(rcan, 0x118) & 0x70) >> 4;
+
+	for (frame = 0; frame < quota; frame++) {
+		rcan->data[frame * 18] = rockchip_canfd_read(rcan, CAN_RXFRD);
+		rcan->data[frame * 18 + 1] = rockchip_canfd_read(rcan, CAN_RXFRD);
+		rcan->data[frame * 18 + 2] = rockchip_canfd_read(rcan, CAN_RXFRD);
+		for (i = 0; i < 16; i++)
+				rcan->data[frame * 18 + i + 3] = rockchip_canfd_read(rcan, CAN_RXFRD);
+	}
+
+	while (work_done < quota) {
+		work_done += rockchip_canfd_rx(ndev, work_done);
+	}
+
+	for (frame = 0; frame < quota; frame++) {
+		rcan->data[frame * 18] = 0;
+		rcan->data[frame * 18 + 1] = 0;
+		rcan->data[frame * 18 + 2] = 0;
+		for (i = 0; i < 16; i++)
+				rcan->data[frame * 18 + i + 3] = 0;
+	}
+
+	if (work_done < 6) {
+		napi_complete_done(napi, work_done);
+	}
+	return work_done;
+}
+
+int zq_test = 0;
+static int rockchip_canfd_err(struct net_device *ndev, u8 isr)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	struct net_device_stats *stats = &ndev->stats;
+	struct can_frame *cf;
+	struct sk_buff *skb;
+	unsigned int rxerr, txerr;
+	u32 sta_reg;
+	
+	skb = alloc_can_err_skb(ndev, &cf);
+
+	rxerr = rockchip_canfd_read(rcan, CAN_RX_ERR_CNT);
+	txerr = rockchip_canfd_read(rcan, CAN_TX_ERR_CNT);
+	sta_reg = rockchip_canfd_read(rcan, CAN_STATE);
+	
+	if (skb) {
+		cf->data[6] = txerr;
+		cf->data[7] = rxerr;
+	}
+
+	if (isr & BUS_OFF_INT) {
+		rcan->can.state = CAN_STATE_BUS_OFF;
+		rcan->can.can_stats.bus_off++;
+		cf->can_id |= CAN_ERR_BUSOFF;
+	} else if (isr & ERR_WARN_INT) {
+		rcan->can.can_stats.error_warning++;
+		rcan->can.state = CAN_STATE_ERROR_WARNING;
+		/* error warning state */
+		if (likely(skb)) {
+			cf->can_id |= CAN_ERR_CRTL;
+			cf->data[1] = (txerr > rxerr) ?
+				CAN_ERR_CRTL_TX_WARNING :
+				CAN_ERR_CRTL_RX_WARNING;
+			cf->data[6] = txerr;
+			cf->data[7] = rxerr;
+		}
+	} else if (isr & PASSIVE_ERR_INT) {
+		rcan->can.can_stats.error_passive++;
+		rcan->can.state = CAN_STATE_ERROR_PASSIVE;
+		/* error passive state */
+		cf->can_id |= CAN_ERR_CRTL;
+		cf->data[1] = (txerr > rxerr) ?
+					CAN_ERR_CRTL_TX_WARNING :
+					CAN_ERR_CRTL_RX_WARNING;
+		cf->data[6] = txerr;
+		cf->data[7] = rxerr;
+	}
+
+	if ((rcan->can.state >= CAN_STATE_BUS_OFF) || ((sta_reg & 0x20) == 0x20)) {
+		zq_test++;
+		can_bus_off(ndev);
+	}
+
+	stats->rx_packets++;
+	stats->rx_bytes += cf->can_dlc;
+	netif_receive_skb(skb);
+
+	return 0;
+}
+
+static irqreturn_t rockchip_canfd_interrupt(int irq, void *dev_id)
+{
+	struct net_device *ndev = (struct net_device *)dev_id;
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	struct net_device_stats *stats = &ndev->stats;
+	u8 err_int = ERR_WARN_INT | RX_BUF_OV_INT | PASSIVE_ERR_INT |
+		     TX_LOSTARB_INT | BUS_ERR_INT;
+	u8 isr;
+	u32 dlc = 0;
+	u32 frame, quota = 0;
+	int i = 0;
+	//unsigned long flags;
+
+	isr = rockchip_canfd_read(rcan, CAN_INT);
+	if (isr & RX_FINISH_INT) {
+		#if 1
+		quota = (rockchip_canfd_read(rcan, 0x118) & 0x70) >> 4;
+
+		for (frame = 0; frame < quota; frame++) {
+			rcan->data[frame * 18] = rockchip_canfd_read(rcan, CAN_RXFRD);
+			rcan->data[frame * 18 + 1] = rockchip_canfd_read(rcan, CAN_RXFRD);
+			rcan->data[frame * 18 + 2] = rockchip_canfd_read(rcan, CAN_RXFRD);
+			for (i = 0; i < 16; i++)
+					rcan->data[frame * 18 + i + 3] = rockchip_canfd_read(rcan, CAN_RXFRD);
+		}
+		for (i = 0; i < quota; i++) {
+			rockchip_canfd_rx(ndev, i);
+		}
+		for (frame = 0; frame < quota; frame++) {
+			rcan->data[frame * 18] = 0;
+			rcan->data[frame * 18 + 1] = 0;
+			rcan->data[frame * 18 + 2] = 0;
+			for (i = 0; i < 16; i++)
+					rcan->data[frame * 18 + i + 3] = 0;
+		}
+		#else
+		napi_schedule(&rcan->napi);
+		#endif
+	}
+
+	if (isr & TX_FINISH_INT) {
+		dlc = rockchip_canfd_read(rcan, CAN_TXFIC);
+		/* transmission complete interrupt */
+		if (dlc & FDF_MASK)
+			stats->tx_bytes += can_fd_dlc2len(dlc & DLC_MASK);
+		else
+			stats->tx_bytes += (dlc & DLC_MASK);
+		stats->tx_packets++;
+	//	spin_lock_irqsave(&rcan->tx_lock, flags);
+		can_get_echo_skb(ndev, 0, 0);
+		netif_wake_queue(ndev);
+	//	spin_unlock_irqrestore(&rcan->tx_lock, flags);
+	}
+
+	isr = rockchip_canfd_read(rcan, CAN_INT);
+	if (isr & err_int) {
+		/* error interrupt */
+		if (rockchip_canfd_err(ndev, isr))
+			netdev_err(ndev, "can't allocate buffer - clearing pending interrupts\n");
+	}
+
+	rockchip_canfd_write(rcan, CAN_INT, isr);
+	return IRQ_HANDLED;
+}
+
+static int rockchip_canfd_open(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	int err;
+
+	/* common open */
+	err = open_candev(ndev);
+	if (err)
+		return err;
+
+	err = pm_runtime_get_sync(rcan->dev);
+	if (err < 0) {
+		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
+			   __func__, err);
+		goto exit;
+	}
+
+	err = rockchip_canfd_start(ndev);
+	if (err) {
+		netdev_err(ndev, "could not start CAN peripheral\n");
+		goto exit_can_start;
+	}
+
+	napi_enable(&rcan->napi);
+	netif_start_queue(ndev);
+
+	netdev_dbg(ndev, "%s\n", __func__);
+	return 0;
+
+exit_can_start:
+	pm_runtime_put(rcan->dev);
+exit:
+	close_candev(ndev);
+	return err;
+}
+
+static int rockchip_canfd_close(struct net_device *ndev)
+{
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);
+	napi_disable(&rcan->napi);
+	rockchip_canfd_stop(ndev);
+	close_candev(ndev);
+	pm_runtime_put(rcan->dev);
+
+	netdev_dbg(ndev, "%s\n", __func__);
+	return 0;
+}
+
+static const struct net_device_ops rockchip_canfd_netdev_ops = {
+	.ndo_open = rockchip_canfd_open,
+	.ndo_stop = rockchip_canfd_close,
+	.ndo_start_xmit = rockchip_canfd_start_xmit,
+	.ndo_change_mtu = can_change_mtu,
+};
+
+/**
+ * rockchip_canfd_suspend - Suspend method for the driver
+ * @dev:	Address of the device structure
+ *
+ * Put the driver into low power mode.
+ * Return: 0 on success and failure value on error
+ */
+static int __maybe_unused rockchip_canfd_suspend(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+
+	if (netif_running(ndev)) {
+		netif_stop_queue(ndev);
+		netif_device_detach(ndev);
+		rockchip_canfd_stop(ndev);
+	}
+
+	return pm_runtime_force_suspend(dev);
+}
+
+/**
+ * rockchip_canfd_resume - Resume from suspend
+ * @dev:	Address of the device structure
+ *
+ * Resume operation after suspend.
+ * Return: 0 on success and failure value on error
+ */
+static int __maybe_unused rockchip_canfd_resume(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret) {
+		dev_err(dev, "pm_runtime_force_resume failed on resume\n");
+		return ret;
+	}
+
+	if (netif_running(ndev)) {
+		ret = rockchip_canfd_start(ndev);
+		if (ret) {
+			dev_err(dev, "rockchip_canfd_chip_start failed on resume\n");
+			return ret;
+		}
+
+		netif_device_attach(ndev);
+		netif_start_queue(ndev);
+	}
+
+	return 0;
+}
+
+/**
+ * rockchip_canfd_runtime_suspend - Runtime suspend method for the driver
+ * @dev:	Address of the device structure
+ *
+ * Put the driver into low power mode.
+ * Return: 0 always
+ */
+static int __maybe_unused rockchip_canfd_runtime_suspend(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+
+	clk_bulk_disable_unprepare(rcan->num_clks, rcan->clks);
+
+	return 0;
+}
+
+/**
+ * rockchip_canfd_runtime_resume - Runtime resume from suspend
+ * @dev:	Address of the device structure
+ *
+ * Resume operation after suspend.
+ * Return: 0 on success and failure value on error
+ */
+static int __maybe_unused rockchip_canfd_runtime_resume(struct device *dev)
+{
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+	int ret;
+
+	ret = clk_bulk_prepare_enable(rcan->num_clks, rcan->clks);
+	if (ret) {
+		dev_err(dev, "Cannot enable clock.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops rockchip_canfd_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_canfd_suspend, rockchip_canfd_resume)
+	SET_RUNTIME_PM_OPS(rockchip_canfd_runtime_suspend,
+			   rockchip_canfd_runtime_resume, NULL)
+};
+
+static const struct of_device_id rockchip_canfd_of_match[] = {
+	{ .compatible = "rockchip,canfd-1.0" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rockchip_canfd_of_match);
+
+static int rockchip_canfd_probe(struct platform_device *pdev)
+{
+	struct net_device *ndev;
+	struct rockchip_canfd *rcan;
+	struct resource *res;
+	void __iomem *addr;
+	int err, irq;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "could not get a valid irq\n");
+		return -ENODEV;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	addr = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(addr))
+		return -EBUSY;
+
+	ndev = alloc_candev(sizeof(struct rockchip_canfd), 1);
+	if (!ndev) {
+		dev_err(&pdev->dev, "could not allocate memory for CANFD device\n");
+		return -ENOMEM;
+	}
+	rcan = netdev_priv(ndev);
+
+	/* register interrupt handler */
+	err = devm_request_irq(&pdev->dev, irq, rockchip_canfd_interrupt,
+			       0, ndev->name, ndev);
+	if (err) {
+		dev_err(&pdev->dev, "request_irq err: %d\n", err);
+		return err;
+	}
+
+	rcan->reset = devm_reset_control_array_get(&pdev->dev, false, false);
+	if (IS_ERR(rcan->reset)) {
+		if (PTR_ERR(rcan->reset) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "failed to get canfd reset lines\n");
+		return PTR_ERR(rcan->reset);
+	}
+	rcan->num_clks = devm_clk_bulk_get_all(&pdev->dev, &rcan->clks);
+	if (rcan->num_clks < 1)
+		return -ENODEV;
+
+	rcan->base = addr;
+	rcan->can.clock.freq = clk_get_rate(rcan->clks[0].clk);
+	rcan->dev = &pdev->dev;
+	rcan->can.state = CAN_STATE_STOPPED;
+	rcan->can.bittiming_const = &rockchip_canfd_bittiming_const;
+	rcan->can.data_bittiming_const = &rockchip_canfd_data_bittiming_const;
+	rcan->can.do_set_mode = rockchip_canfd_set_mode;
+	rcan->can.do_get_berr_counter = rockchip_canfd_get_berr_counter;
+	rcan->can.do_set_bittiming = rockchip_canfd_set_bittiming;
+	rcan->can.do_set_data_bittiming = rockchip_canfd_set_bittiming;
+	rcan->can.ctrlmode = CAN_CTRLMODE_FD;
+	/* IFI CANFD can do both Bosch FD and ISO FD */
+	rcan->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |
+				       CAN_CTRLMODE_FD;
+	rcan->can.restart_ms = 1;
+
+	ndev->netdev_ops = &rockchip_canfd_netdev_ops;
+	ndev->irq = irq;
+	ndev->flags |= IFF_ECHO;
+	spin_lock_init(&rcan->tx_lock);
+
+	platform_set_drvdata(pdev, ndev);
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	pm_runtime_enable(&pdev->dev);
+	err = pm_runtime_get_sync(&pdev->dev);
+	if (err < 0) {
+		dev_err(&pdev->dev, "%s: pm_runtime_get failed(%d)\n",
+			__func__, err);
+		goto err_pmdisable;
+	}
+	netif_napi_add(ndev, &rcan->napi, rockchip_canfd_rx_poll);
+	err = register_candev(ndev);
+	if (err) {
+		dev_err(&pdev->dev, "registering %s failed (err=%d)\n",
+			DRV_NAME, err);
+		goto err_disableclks;
+	}
+
+	return 0;
+
+err_disableclks:
+	pm_runtime_put(&pdev->dev);
+err_pmdisable:
+	pm_runtime_disable(&pdev->dev);
+	free_candev(ndev);
+
+	return err;
+}
+
+static int rockchip_canfd_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct rockchip_canfd *rcan = netdev_priv(ndev);
+
+	unregister_netdev(ndev);
+	pm_runtime_disable(&pdev->dev);
+	netif_napi_del(&rcan->napi);
+	free_candev(ndev);
+
+	return 0;
+}
+
+static struct platform_driver rockchip_canfd_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.pm = &rockchip_canfd_dev_pm_ops,
+		.of_match_table = rockchip_canfd_of_match,
+	},
+	.probe = rockchip_canfd_probe,
+	.remove = rockchip_canfd_remove,
+};
+module_platform_driver(rockchip_canfd_driver);
+
+MODULE_AUTHOR("Elaine Zhang <zhangqing@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip CANFD Drivers");
diff --git a/drivers/usb/typec/tcpm/fusb302.c b/drivers/usb/typec/tcpm/fusb302.c
index 7fc1ffa14f76..ec95221ac4a8 100644
--- a/drivers/usb/typec/tcpm/fusb302.c
+++ b/drivers/usb/typec/tcpm/fusb302.c
@@ -1748,7 +1748,7 @@ static int fusb302_probe(struct i2c_client *client)
 	}
 
 	ret = request_irq(chip->gpio_int_n_irq, fusb302_irq_intn,
-			  IRQF_ONESHOT | IRQF_TRIGGER_LOW,
+			  IRQF_TRIGGER_LOW,
 			  "fsc_interrupt_int_n", chip);
 	if (ret < 0) {
 		dev_err(dev, "cannot request IRQ for GPIO Int_N, ret=%d", ret);
diff --git a/drivers/usb/typec/tcpm/tcpm.c b/drivers/usb/typec/tcpm/tcpm.c
index cc1d83926497..4bb545822f99 100644
--- a/drivers/usb/typec/tcpm/tcpm.c
+++ b/drivers/usb/typec/tcpm/tcpm.c
@@ -5465,8 +5465,17 @@ static void tcpm_pd_event_handler(struct kthread_work *work)
 		if (events & TCPM_CC_EVENT) {
 			enum typec_cc_status cc1, cc2;
 
-			if (port->tcpc->get_cc(port->tcpc, &cc1, &cc2) == 0)
+			if (port->tcpc->get_cc(port->tcpc, &cc1, &cc2) == 0) {
 				_tcpm_cc_change(port, cc1, cc2);
+				if (tcpm_port_is_source(port)) {
+					enum typec_cc_polarity polarity =
+						port->cc2 == TYPEC_CC_RD ? TYPEC_POLARITY_CC2
+							 : TYPEC_POLARITY_CC1;
+					tcpm_set_polarity(port, polarity);
+					tcpm_set_roles(port, port->attached, TYPEC_SOURCE,
+						       tcpm_data_role_for_source(port));
+				}
+			}
 		}
 		if (events & TCPM_FRS_EVENT) {
 			if (port->state == SNK_READY) {
